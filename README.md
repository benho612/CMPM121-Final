# CMPM121-Final 
# Devlog Entry - [12-4-2025]  
## How we satisfied the software requirements  
For the F3 requirements, we decided to satisfy numbers 3, 4, 5, and 6. For number 3, the reason we did this is that this fits our game the best, since there's nothing like water buckets, or anything like that would need to live that long. However, at the same time, we want to provide the chance for the player to resume their game if they decided to do something else in the meantime. The reason we picked 4 is that we also decided to pick number 5; we thought they would be a good combination since some people would keep their phone's default theme as dark. The reason we picked number 5 is that we want  people to try our game on the phone, will also be supportive of number 4. Lastly, we picked number 6 since we want more people to try our game. By providing a multi-language environment, this game shows diversity. 
## How we satisfied the software requirements  
Our game meets the required features through systems built directly into the project. The save system lets players store progress in three save slots, and it also auto-saves so they never lose progress if the game closes by accident. The visual theme feature works by checking the player’s device settings and automatically switching the game between light mode and dark mode, changing not just UI colors but also the lighting and look of the 3D rooms. The game fully supports touchscreen play through a built-in virtual joystick and tap-based interactions, so players do not need a mouse or keyboard at all. Finally, the game includes three languages: English, Chinese, and Arabic, and the interface correctly switches layouts when Arabic is selected, including right-to-left text direction. With all these features show that the project meets all requirements in a complete and functional way.
## Reflection  
The original gameplay got to stay; we mainly changed the feeling of the game. We added auto-saving, dark/bright/current system theme, touch screen availability, and two more languages of Chinese and Arabic. I'm glad that we don't have to do any more system changes; otherwise, it would be too much workload for all of us. However, through the system change in F1, we learn about this new game-dev system, the "new" physics engine, and how we can implement this game as a screen-touch game. 
  
# Devlog Entry - [12-1-2025]  
## How we satisfied the software requirements
We kept the HTML5 + JavaScript with Cannon-es format that satisfies the F1 requirements. This is working great, so we don't want to change this. In this stage of development, we designed several rooms with different objects that the player can obtain. By going through different rooms, the player needs to collect all the items and get the key to escape. Normally, the player can click on the item to collect it, but the key needs to be collected through a quick physics puzzle. After collecting the key, the player will need to find the correct door to escape. There's an inventory box on the top right, so the player can keep track of what items they have collected. In the physical puzzle, the player will fail the obtain the key if they drop the ball outside the platform. Currently, there's one conclusive ending of the player has solved the puzzle. 

## Reflection
We updated the main mechanic of the gameplay. It used to be a physical puzzle, but now we have added the random room/door mechanic to make the game more interesting. Along with the updated UI and inventory system, the player will feel more immersive.   
  
# Devlog Entry - [11-21-2025]  
- updated DevLog to reflect changes
## How we satisfied the software requirements
We built the prototype using standard HTML5 and JavaScript. This browser DOM has no native concept of 3D rendering or rigid body physics simulations, which satisfies the built-in physics requirements. For third-party 3D rendering library, we integrated Three.js that hendles the WebGL context, scene graph, camera, and etc. For third-party physics sim, we use cannon-es. This is a pure JavaScript physics engine. Handles collision detection and rigid body dynamics. The game we did is a balance puzzle. The player uses the Arrow Keys to manipulate the simulation. Specifically, we mapped user input to the rotation of the floor's Kinematic Body. By tilting the floor, the player alters the gravity vector relative to the ball, causing it to roll. The success/failure detection is based on a logic check every frame. If the ball's Y goes below -10 units, then its "dropping from the platform". If the ball's coordinate enters the radius of the target zone, then game triggers a success state. We set up Husky and lint-staged. Before any commit is allowed, our configuration runs eslint to check for syntax errors and prettier to enforce code style. If the code is messy or broken, the commit is blocked, ensuring the repo stays clean. We implemented a GitHub Actions workflow. Upon pushing to the main branch, the action spins up a container, runs our linting checks one last time, and then uses the actions/deploy-pages workflow to automatically publish the latest version of the game to GitHub Pages.
  
## Reflection
We have decided on the mechanics of the game very smoothly. However, we all had a hard time deploying lua with the thirdparty 3D engine, so we decided to change it. We decided to use HTML5 and JavaScript. This seems to work better with our workflow and easier to use. The game is a balance puzzle. A ball spawns on a platform that is subject to gravity. The "puzzle" element is navigating the ball around a flat surface without letting it slide off the edge due to gravity, requiring momentum management.  
  
# Devlog Entry - [11-13-2025]  
- updated README.md  
## Introducing the team  
- Tools Lead: Eric Cai  
- Engine Lead: Ben Ho  
- Design Lead: Toby Pang  
- Testing Lead: Sett Paing Htin  
## Tools and materials  
- Engine: We plan to use LÖVE2D ( https://love2d.org/ ) as our primary engine. It gives us a lightweight 2D framework without any built-in high-level physics or 3D rendering, which fits perfectly with the project rules. LÖVE2D keeps the technical surface small but still powerful enough for custom rendering, input, and asset handling. It also allows us to structure our architecture cleanly rather than relying on an engine that “does everything” for us.  
- Language: We will use Lua as the main programming language since it is the required language for LÖVE2D. Lua is simple, fast, and easy for the whole team to pick up, and its flexibility should help us iterate on gameplay systems quickly. For data storage we expect to use plain Lua tables or lightweight formats like JSON if needed, depending on how we structure content.  
- Tools: For development, our team will primarily use VS Code (https://code.visualstudio.com/) because it has strong Lua extensions and is easy for everyone to configure consistently. For art and asset creation, we’re planning to use simple tools like Aseprite or Krita, depending on what each person is comfortable with. Our focus is rapid iteration instead of producing high-fidelity art early, so having tools that let us generate and edit sprites quickly is ideal.  
- Generative AI: Our plan is to treat generative AI as a support tool rather than a production tool. We will allow teammates to use GitHub Copilot for autocomplete, boilerplate generation, and proofreading small functions, but not for generating large files or full systems on its own. We want to keep design decisions human-driven and make sure all teammates understand the code they write. We may also use it for debugging explanations or technical guidance, but not for producing final assets or gameplay code automatically.  
## Outlook  
As a team, we’re aiming to build a game that feels polished and intentional, even within the constraints of a small custom engine setup. Working with Lua and LÖVE2D gives us freedom, but it also means we’ll need to design our own structure for everything—from game loops to gameplay systems. The riskiest part will probably be coordinating our code architecture so multiple people can contribute without stepping on each other’s work. Still, we’re excited because using a minimal engine should help us learn more about how games actually run under the hood, instead of depending on a large engine to do the hard parts for us. Overall, we want to keep our scope tight but still create something that feels like a complete game experience.  
