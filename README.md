# CMPM121-Final 
# Devlog Entry - [11-21-2025]  
- updated DevLog to reflect changes
## How we satisfied the software requirements
We built the prototype using standard HTML5 and JavaScript. This browser DOM has no native concept of 3D rendering or rigid body physics simulations, which satisfies the built-in physics requirements. For third-party 3D rendering library, we integrated Three.js that hendles the WebGL context, scene graph, camera, and etc. For third-party physics sim, we use cannon-es. This is a pure JavaScript physics engine. Handles collision detection and rigid body dynamics. The game we did is a balance puzzle. The player uses the Arrow Keys to manipulate the simulation. Specifically, we mapped user input to the rotation of the floor's Kinematic Body. By tilting the floor, the player alters the gravity vector relative to the ball, causing it to roll. The success/failure detection is based on a logic check every frame. If the ball's Y goes below -10 units, then its "dropping from the platform". If the ball's coordinate enters the radius of the target zone, then game triggers a success state. We set up Husky and lint-staged. Before any commit is allowed, our configuration runs eslint to check for syntax errors and prettier to enforce code style. If the code is messy or broken, the commit is blocked, ensuring the repo stays clean. We implemented a GitHub Actions workflow. Upon pushing to the main branch, the action spins up a container, runs our linting checks one last time, and then uses the actions/deploy-pages workflow to automatically publish the latest version of the game to GitHub Pages.
  
## Reflection
We have decided on the mechanics of the game very smoothly. However, we all had a hard time deploying lua with the thirdparty 3D engine, so we decided to change it. We decided to use HTML5 and JavaScript. This seems to work better with our workflow and easier to use. The game is a balance puzzle. A ball spawns on a platform that is subject to gravity. The "puzzle" element is navigating the ball around a flat surface without letting it slide off the edge due to gravity, requiring momentum management.  
  
# Devlog Entry - [11-13-2025]  
- updated README.md  
## Introducing the team  
- Tools Lead: Eric Cai  
- Engine Lead: Ben Ho  
- Design Lead: Toby Pang  
- Testing Lead: Sett Paing Htin  
## Tools and materials  
- Engine: We plan to use LÖVE2D ( https://love2d.org/ ) as our primary engine. It gives us a lightweight 2D framework without any built-in high-level physics or 3D rendering, which fits perfectly with the project rules. LÖVE2D keeps the technical surface small but still powerful enough for custom rendering, input, and asset handling. It also allows us to structure our architecture cleanly rather than relying on an engine that “does everything” for us.  
- Language: We will use Lua as the main programming language since it is the required language for LÖVE2D. Lua is simple, fast, and easy for the whole team to pick up, and its flexibility should help us iterate on gameplay systems quickly. For data storage we expect to use plain Lua tables or lightweight formats like JSON if needed, depending on how we structure content.  
- Tools: For development, our team will primarily use VS Code (https://code.visualstudio.com/) because it has strong Lua extensions and is easy for everyone to configure consistently. For art and asset creation, we’re planning to use simple tools like Aseprite or Krita, depending on what each person is comfortable with. Our focus is rapid iteration instead of producing high-fidelity art early, so having tools that let us generate and edit sprites quickly is ideal.  
- Generative AI: Our plan is to treat generative AI as a support tool rather than a production tool. We will allow teammates to use GitHub Copilot for autocomplete, boilerplate generation, and proofreading small functions, but not for generating large files or full systems on its own. We want to keep design decisions human-driven and make sure all teammates understand the code they write. We may also use it for debugging explanations or technical guidance, but not for producing final assets or gameplay code automatically.  
## Outlook  
As a team, we’re aiming to build a game that feels polished and intentional, even within the constraints of a small custom engine setup. Working with Lua and LÖVE2D gives us freedom, but it also means we’ll need to design our own structure for everything—from game loops to gameplay systems. The riskiest part will probably be coordinating our code architecture so multiple people can contribute without stepping on each other’s work. Still, we’re excited because using a minimal engine should help us learn more about how games actually run under the hood, instead of depending on a large engine to do the hard parts for us. Overall, we want to keep our scope tight but still create something that feels like a complete game experience.  
