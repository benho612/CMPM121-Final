<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>F2 Prototype: Gravity Escape (Touch Enabled)</title>
    <style>
        :root {
            color-scheme: light dark;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #111;
            color: #fff;
            /* Prevent touch actions like pull-to-refresh on mobile */
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: inherit;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            max-width: 340px;
            pointer-events: auto; /* Allow clicking text if needed */
        }
        #inventory-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            color: inherit;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 10;
        }
        #status-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            display: none;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
            z-index: 20;
            white-space: pre-line;
            pointer-events: none;
        }
        .win { color: #4ade80; }
        .lose { color: #f87171; }

        #start-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        #message {
            position: absolute;
            bottom: 80px; /* Moved up slightly to avoid touch controls */
            left: 50%;
            transform: translateX(-50%);
            color: inherit;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 16px;
            display: none;
            z-index: 15;
            pointer-events: none;
        }

        #save-ui {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 8px;
            border-radius: 4px;
            color: #fff;
            font-size: 11px;
            z-index: 12;
        }
        #save-ui span {
            font-weight: bold;
            margin-right: 6px;
        }
        #save-ui button {
            margin: 1px 2px;
            font-size: 11px;
            cursor: pointer;
            padding: 4px 8px; /* Larger touch target */
        }

        #theme-ui {
            position: absolute;
            bottom: 10px;
            left: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 8px;
            border-radius: 4px;
            color: #fff;
            font-size: 11px;
            z-index: 12;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #theme-ui span {
            font-weight: bold;
            margin-right: 4px;
        }
        #theme-ui button {
            margin: 0 2px;
            font-size: 11px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(15, 23, 42, 0.7);
            color: inherit;
            border-radius: 3px;
            padding: 4px 8px; /* Larger touch target */
        }
        #theme-ui button.active {
            border-color: #22c55e;
            font-weight: bold;
        }

        /* --- TOUCH CONTROLS --- */
        #touch-controls {
            position: absolute;
            bottom: 60px;
            right: 20px;
            display: none; /* Hidden by default, shown in puzzle */
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 30;
        }
        .dpad-row {
            display: flex;
            gap: 10px;
        }
        .dpad-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            user-select: none;
            touch-action: none;
        }
        .dpad-btn:active, .dpad-btn.pressed {
            background: rgba(74, 222, 128, 0.5);
            border-color: #4ade80;
        }

        #puzzle-restart-btn {
            position: absolute;
            bottom: 60px;
            left: 20px;
            display: none; /* Hidden by default */
            z-index: 30;
            width: 60px;
            height: 60px;
            background: rgba(248, 113, 113, 0.3);
            border: 2px solid rgba(248, 113, 113, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            backdrop-filter: blur(4px);
            touch-action: none;
        }
        #puzzle-restart-btn:active {
            background: rgba(248, 113, 113, 0.6);
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: #dbeafe;
                color: #111827;
            }
            #instructions {
                background: rgba(255, 255, 255, 0.9);
                color: #111827;
            }
            #inventory-ui {
                background: rgba(255, 255, 255, 0.85);
                color: #111827;
            }
            #message {
                background: rgba(15, 23, 42, 0.9);
                color: #e5e7eb;
            }
            #save-ui, #theme-ui {
                background: rgba(255, 255, 255, 0.75);
                color: #111827;
            }
            #theme-ui button {
                background: rgba(241, 245, 249, 0.9);
            }
            #start-text {
                color: #111827;
                text-shadow: 2px 2px 4px #ffffff88;
            }
            .dpad-btn, #puzzle-restart-btn {
                background: rgba(0, 0, 0, 0.1);
                border-color: rgba(0, 0, 0, 0.2);
                color: #111;
            }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="ui-layer">
        <div id="instructions"></div>
    </div>

    <div id="inventory-ui">Inventory: (empty)</div>
    <div id="status-msg"></div>
    <div id="message"></div>

    <div id="start-text">TAP TO START ↓</div>

    <div id="puzzle-restart-btn">↺</div>
    <div id="touch-controls">
        <div class="dpad-btn" id="btn-up">▲</div>
        <div class="dpad-row">
            <div class="dpad-btn" id="btn-left">◀</div>
            <div class="dpad-btn" id="btn-right">▶</div>
        </div>
        <div class="dpad-btn" id="btn-down">▼</div>
    </div>

    <div id="save-ui">
        <span>Saves:</span>
        <button data-slot="slot1" data-action="save">Save 1</button>
        <button data-slot="slot1" data-action="load">Load 1</button>
        <button data-slot="slot2" data-action="save">Save 2</button>
        <button data-slot="slot2" data-action="load">Load 2</button>
        <button data-slot="slot3" data-action="save">Save 3</button>
        <button data-slot="slot3" data-action="load">Load 3</button>
        <button data-slot="restart" data-action="restart">Restart</button>
    </div>

    <div id="theme-ui">
        <span>Theme:</span>
        <button data-theme="system" class="active">Auto</button>
        <button data-theme="light">Light</button>
        <button data-theme="dark">Dark</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, renderer;
        let world;
        const timeStep = 1 / 60;

        // Cameras
        let perspCamera, orthoCamera, camera;
        const viewSize = 15;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Modes: menu | maze | puzzle | ending
        let currentMode = "menu";

        // Maze rooms: 3x3
        const NUM_ROWS = 3;
        const NUM_COLS = 3;
        const CENTER_ROW = 1;
        const CENTER_COL = 1;
        const mazeRooms = [];
        let currentRoomRow = CENTER_ROW;
        let currentRoomCol = CENTER_COL;

        // When entering puzzle, remember which room we came from
        let returnRoomRow = CENTER_ROW;
        let returnRoomCol = CENTER_COL;

        // Screen shake state
        let shakeTime = 0;
        let shakeDuration = 0;
        let shakeIntensity = 0;
        const cameraBasePosition = new THREE.Vector3();

        // Lighting and theme
        let ambientLight;
        let dirLight;
        let themeMode = "system"; 
        let systemPrefersDark = false;

        const mazeFloorMats = [];
        const mazeWallMats = [];
        let puzzleFloorMat = null;

        let menuGroup;
        let puzzleGroup;

        // Physics objects (puzzle)
        let ballMesh, ballBody;
        let floorMesh, floorBody;
        let targetMesh;

        // Game state / inventory
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const TARGET_POS = { x: 8, z: 8 };
        const TARGET_RADIUS = 1.5;

        const inventory = new Set();
        let hasKey = false;
        let gameActive = false;

        let ballRoomCoord = null;
        let plateRoomCoord = null;
        let portalRoomCoord = null;

        const SAVE_PREFIX = "gravityEscape_";
        const AUTO_SLOT = "autosave";
        let pendingLoadData = null;

        // --- Load existing save ---
        try {
            const raw = localStorage.getItem(SAVE_PREFIX + AUTO_SLOT);
            if (raw) {
                pendingLoadData = JSON.parse(raw);
                if (pendingLoadData && typeof pendingLoadData === "object") {
                    currentMode = pendingLoadData.currentMode || "maze";
                    currentRoomRow = pendingLoadData.currentRoomRow ?? CENTER_ROW;
                    currentRoomCol = pendingLoadData.currentRoomCol ?? CENTER_COL;
                    returnRoomRow = pendingLoadData.returnRoomRow ?? CENTER_ROW;
                    returnRoomCol = pendingLoadData.returnRoomCol ?? CENTER_COL;
                    hasKey = !!pendingLoadData.hasKey;

                    if (Array.isArray(pendingLoadData.inventory)) {
                        pendingLoadData.inventory.forEach(id => inventory.add(id));
                    }

                    ballRoomCoord = pendingLoadData.ballRoomCoord || null;
                    plateRoomCoord = pendingLoadData.plateRoomCoord || null;
                    portalRoomCoord = pendingLoadData.portalRoomCoord || null;

                    if (pendingLoadData.themeMode) {
                        themeMode = pendingLoadData.themeMode;
                    }
                }
            }
        } catch (e) {
            console.warn("Failed to parse autosave:", e);
            pendingLoadData = null;
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202025);
            scene.fog = new THREE.Fog(0x202025, 10, 60);

            const aspect = window.innerWidth / window.innerHeight;

            perspCamera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100);
            perspCamera.position.set(0, 20, 25);
            perspCamera.lookAt(0, 0, 0);

            orthoCamera = new THREE.OrthographicCamera(
                -viewSize * aspect, viewSize * aspect, viewSize, -viewSize, 0.1, 100
            );
            orthoCamera.position.set(0, 25, 0);
            orthoCamera.lookAt(0, 0, 0);
            orthoCamera.up.set(0, 0, -1);

            camera = perspCamera;
            cameraBasePosition.copy(camera.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            // Handle high DPI screens
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0)
            });

            const physicsMaterial = new CANNON.Material('physics');
            const physicsContactMaterial = new CANNON.ContactMaterial(
                physicsMaterial, physicsMaterial, { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(physicsContactMaterial);

            menuGroup = new THREE.Group();
            scene.add(menuGroup);

            for (let r = 0; r < NUM_ROWS; r++) {
                mazeRooms[r] = [];
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = new THREE.Group();
                    mazeRooms[r][c] = g;
                    scene.add(g);
                }
            }

            puzzleGroup = new THREE.Group();
            scene.add(puzzleGroup);

            // --- MENU ---
            {
                const startButtonGeo = new THREE.PlaneGeometry(6, 2);
                const startButtonMat = new THREE.MeshBasicMaterial({ color: 0x44ff88, side: THREE.DoubleSide });
                const startButton = new THREE.Mesh(startButtonGeo, startButtonMat);
                startButton.position.set(0, 10, 0);
                startButton.rotation.x = -Math.PI / 4;
                startButton.userData.type = "startGame";
                menuGroup.add(startButton);
            }

            // Build Rooms
            function buildBasicRoom(group) {
                const floorGeo = new THREE.BoxGeometry(12, 1, 12);
                const floorMat = new THREE.MeshStandardMaterial({ color: 0x444466 });
                mazeFloorMats.push(floorMat);
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.receiveShadow = true;
                floor.position.y = 0;
                group.add(floor);

                const wallGeoZ = new THREE.BoxGeometry(12, 1.2, 0.5);
                const wallGeoX = new THREE.BoxGeometry(0.5, 1.2, 12);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x222233 });
                mazeWallMats.push(wallMat);

                const backWall = new THREE.Mesh(wallGeoZ, wallMat); backWall.position.set(0, 0.6, -6); group.add(backWall);
                const frontWall = new THREE.Mesh(wallGeoZ, wallMat); frontWall.position.set(0, 0.6, 6); group.add(frontWall);
                const leftWall = new THREE.Mesh(wallGeoX, wallMat); leftWall.position.set(-6, 0.6, 0); group.add(leftWall);
                const rightWall = new THREE.Mesh(wallGeoX, wallMat); rightWall.position.set(6, 0.6, 0); group.add(rightWall);
            }

            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    buildBasicRoom(mazeRooms[r][c]);
                }
            }

            const doorGeo = new THREE.BoxGeometry(2, 3, 0.5);
            const doorMatMaze = new THREE.MeshStandardMaterial({ color: 0x64748b });

            function addMazeDoor(group, direction, targetRow, targetCol) {
                const door = new THREE.Mesh(doorGeo, doorMatMaze);
                door.userData.type = "door";
                door.userData.kind = "mazeDoor";
                door.userData.row = targetRow;
                door.userData.col = targetCol;

                if (direction === "north") door.position.set(0, 1.5, -5.75);
                else if (direction === "south") door.position.set(0, 1.5, 5.75);
                else if (direction === "west") { door.rotation.y = Math.PI / 2; door.position.set(-5.75, 1.5, 0); }
                else if (direction === "east") { door.rotation.y = Math.PI / 2; door.position.set(5.75, 1.5, 0); }
                group.add(door);
            }

            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = mazeRooms[r][c];
                    if (r > 0) addMazeDoor(g, "north", r - 1, c);
                    if (r < NUM_ROWS - 1) addMazeDoor(g, "south", r + 1, c);
                    if (c > 0) addMazeDoor(g, "west", r, c - 1);
                    if (c < NUM_COLS - 1) addMazeDoor(g, "east", r, c + 1);
                }
            }

            if (!ballRoomCoord || !plateRoomCoord || !portalRoomCoord) {
                const coords = [];
                for (let r = 0; r < NUM_ROWS; r++) {
                    for (let c = 0; c < NUM_COLS; c++) {
                        if (r === CENTER_ROW && c === CENTER_COL) continue;
                        coords.push({ r, c });
                    }
                }
                shuffleArray(coords);
                if (!ballRoomCoord) ballRoomCoord = coords[0];
                if (!plateRoomCoord) plateRoomCoord = coords[1];
                if (!portalRoomCoord) portalRoomCoord = coords[2];
            }

            // Ball
            {
                const { r, c } = ballRoomCoord;
                const group = mazeRooms[r][c];
                const ballGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4b4b });
                const ball = new THREE.Mesh(ballGeo, ballMat);
                ball.position.set(0, 1, 0);
                ball.castShadow = true;
                ball.userData.type = "item";
                ball.userData.itemId = "ball";
                group.add(ball);
            }

            // Plate
            {
                const { r, c } = plateRoomCoord;
                const group = mazeRooms[r][c];
                const plateGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.2, 32);
                const plateMat = new THREE.MeshStandardMaterial({ color: 0x4ade80 });
                const plate = new THREE.Mesh(plateGeo, plateMat);
                plate.position.set(0, 1, 0);
                plate.castShadow = true;
                plate.userData.type = "item";
                plate.userData.itemId = "plate";
                group.add(plate);
            }

            // Portal
            {
                const { r, c } = portalRoomCoord;
                const group = mazeRooms[r][c];
                const portalGeo = new THREE.BoxGeometry(2, 3, 0.5);
                const portalMat = new THREE.MeshStandardMaterial({ color: 0x8b5cf6 });
                const portalDoor = new THREE.Mesh(portalGeo, portalMat);
                portalDoor.userData.type = "door";
                portalDoor.userData.kind = "finalExit";
                portalDoor.userData.target = "ending";

                if (r === 0) portalDoor.position.set(0, 1.5, -5.75);
                else if (r === NUM_ROWS - 1) portalDoor.position.set(0, 1.5, 5.75);
                else if (c === 0) { portalDoor.rotation.y = Math.PI / 2; portalDoor.position.set(-5.75, 1.5, 0); }
                else { portalDoor.rotation.y = Math.PI / 2; portalDoor.position.set(5.75, 1.5, 0); }
                group.add(portalDoor);
            }

            // --- PUZZLE ROOM ---
            {
                const floorGeoB = new THREE.BoxGeometry(20, 1, 20);
                const floorMatB = new THREE.MeshStandardMaterial({ color: 0x666644 });
                puzzleFloorMat = floorMatB;
                floorMesh = new THREE.Mesh(floorGeoB, floorMatB);
                floorMesh.receiveShadow = true;
                puzzleGroup.add(floorMesh);

                const floorShape = new CANNON.Box(new CANNON.Vec3(10, 0.5, 10));
                floorBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: physicsMaterial });
                floorBody.addShape(floorShape);
                world.addBody(floorBody);

                const ballRadius = 0.8;
                const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 });
                ballMesh = new THREE.Mesh(ballGeo, ballMat);
                ballMesh.castShadow = true;
                puzzleGroup.add(ballMesh);

                const ballShape = new CANNON.Sphere(ballRadius);
                ballBody = new CANNON.Body({ mass: 5, shape: ballShape, material: physicsMaterial });
                ballBody.position.set(-5, 5, -5);
                ballBody.linearDamping = 0.1;
                world.addBody(ballBody);

                const targetGeo = new THREE.CylinderGeometry(TARGET_RADIUS, TARGET_RADIUS, 0.1, 32);
                const targetMat = new THREE.MeshBasicMaterial({ color: 0x4ade80, opacity: 0.5, transparent: true });
                targetMesh = new THREE.Mesh(targetGeo, targetMat);
                targetMesh.position.set(TARGET_POS.x, 0.6, TARGET_POS.z);
                floorMesh.add(targetMesh);
            }

            // --- EVENT LISTENERS ---
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
                if (e.key.toLowerCase() === 'r') restartGame();
            });
            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            });

            // --- Touch UI Logic ---
            setupTouchControls();

            // Save UI
            document.getElementById('save-ui').addEventListener('click', (e) => {
                const btn = e.target;
                if (!(btn instanceof HTMLButtonElement)) return;
                const slot = btn.dataset.slot;
                const action = btn.dataset.action;
                if (!action) return;
                if (action === 'save' || action === 'load') {
                    if (!slot) return;
                    if (action === 'save') { saveGame(slot); showStatus("Saved to " + slot.toUpperCase(), 1000); }
                    else if (action === 'load') { loadGame(slot); }
                } else if (action === 'restart') {
                    fullRestart();
                }
            });

            // Theme UI
            document.getElementById('theme-ui').addEventListener('click', (e) => {
                const btn = e.target;
                if (!(btn instanceof HTMLButtonElement)) return;
                const mode = btn.dataset.theme;
                if (!mode) return;
                themeMode = mode;
                updateThemeButtons();
                recomputeTheme();
                saveGame(AUTO_SLOT);
            });
            updateThemeButtons();

            window.addEventListener('beforeunload', () => saveGame(AUTO_SLOT));
            updateInventoryUI();
            setupThemeFromSystem();

            if (pendingLoadData) applyLoadedData(pendingLoadData, true);
            else loadMenu();
        }

        // --- Touch Control Setup ---
        function setupTouchControls() {
            const bindTouch = (id, key) => {
                const el = document.getElementById(id);
                const setKey = (val) => {
                    keys[key] = val;
                    if(val) el.classList.add('pressed');
                    else el.classList.remove('pressed');
                };

                // Pointer events cover mouse and touch
                el.addEventListener('pointerdown', (e) => {
                    e.preventDefault();
                    e.stopPropagation(); // Don't trigger 3D raycast
                    setKey(true);
                    el.setPointerCapture(e.pointerId);
                });
                
                ['pointerup', 'pointercancel', 'pointerleave'].forEach(evt => {
                    el.addEventListener(evt, (e) => {
                        e.preventDefault();
                        setKey(false);
                    });
                });
            };

            bindTouch('btn-up', 'ArrowUp');
            bindTouch('btn-down', 'ArrowDown');
            bindTouch('btn-left', 'ArrowLeft');
            bindTouch('btn-right', 'ArrowRight');

            // Restart Button
            const rBtn = document.getElementById('puzzle-restart-btn');
            rBtn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                restartGame();
            });
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function startScreenShake(duration = 0.4, intensity = 0.6) {
            shakeDuration = duration; shakeTime = duration; shakeIntensity = intensity;
            cameraBasePosition.copy(camera.position);
        }

        function updateScreenShake() {
            if (shakeTime <= 0) return;
            const progress = 1 - shakeTime / shakeDuration;
            const damper = 1 - progress;
            const offsetX = (Math.random() - 0.5) * 2 * shakeIntensity * damper;
            const offsetY = (Math.random() - 0.5) * 2 * shakeIntensity * damper;
            camera.position.set(cameraBasePosition.x + offsetX, cameraBasePosition.y + offsetY, cameraBasePosition.z);
            shakeTime -= timeStep;
            if (shakeTime <= 0) camera.position.copy(cameraBasePosition);
        }

        function applyTheme(mode) {
            if (!scene || !ambientLight || !dirLight) return;
            if (mode === "dark") {
                scene.background.set(0x050816);
                scene.fog.color.set(0x050816);
                ambientLight.intensity = 0.45;
                dirLight.intensity = 0.9;
                dirLight.color.set(0xbfd7ff);
                mazeFloorMats.forEach(m => { m.color.set(0x1e293b); m.roughness = 0.9; m.metalness = 0.0; });
                mazeWallMats.forEach(m => { m.color.set(0x020617); m.roughness = 0.9; m.metalness = 0.0; });
                if (puzzleFloorMat) { puzzleFloorMat.color.set(0x1f2933); puzzleFloorMat.roughness = 0.85; puzzleFloorMat.metalness = 0.05; }
            } else {
                scene.background.set(0xcbe5ff);
                scene.fog.color.set(0xcbe5ff);
                ambientLight.intensity = 0.95;
                dirLight.intensity = 0.85;
                dirLight.color.set(0xfff2cf);
                mazeFloorMats.forEach(m => { m.color.set(0xe2e8f0); m.roughness = 0.6; m.metalness = 0.1; });
                mazeWallMats.forEach(m => { m.color.set(0xf8fafc); m.roughness = 0.7; m.metalness = 0.0; });
                if (puzzleFloorMat) { puzzleFloorMat.color.set(0xfacc6b); puzzleFloorMat.roughness = 0.7; puzzleFloorMat.metalness = 0.1; }
            }
            renderer.setClearColor(scene.background);
        }

        function recomputeTheme() {
            const effective = themeMode === "light" || themeMode === "dark" ? themeMode : (systemPrefersDark ? "dark" : "light");
            applyTheme(effective);
        }

        function setupThemeFromSystem() {
            if (window.matchMedia) {
                const mq = window.matchMedia("(prefers-color-scheme: dark)");
                systemPrefersDark = mq.matches;
                recomputeTheme();
                mq.addEventListener("change", (e) => {
                    systemPrefersDark = e.matches;
                    if (themeMode === "system") recomputeTheme();
                });
            } else {
                systemPrefersDark = false;
                recomputeTheme();
            }
        }

        function updateThemeButtons() {
            const themeUI = document.getElementById('theme-ui');
            const buttons = themeUI.querySelectorAll('button[data-theme]');
            buttons.forEach(btn => {
                if (btn.dataset.theme === themeMode) btn.classList.add('active');
                else btn.classList.remove('active');
            });
        }

        function buildSaveData() {
            return {
                version: 2, currentMode, currentRoomRow, currentRoomCol, returnRoomRow, returnRoomCol,
                hasKey, inventory: Array.from(inventory), ballRoomCoord, plateRoomCoord, portalRoomCoord, themeMode
            };
        }

        function saveGame(slot = AUTO_SLOT) {
            try { localStorage.setItem(SAVE_PREFIX + slot, JSON.stringify(buildSaveData())); } catch (e) { console.warn("Save failed:", e); }
        }

        function loadGame(slot) {
            try {
                const key = SAVE_PREFIX + slot;
                const raw = localStorage.getItem(key);
                if (!raw) { showStatus("No save in " + slot.toUpperCase(), 1500); return; }
                const data = JSON.parse(raw);
                applyLoadedData(data, false);
                showStatus("Loaded " + slot.toUpperCase(), 1000);
            } catch (e) { console.warn("Load failed:", e); }
        }

        function applyLoadedData(data, fromInit) {
            if (!data || typeof data !== "object") return;
            pendingLoadData = data;
            currentMode = data.currentMode || "maze";
            currentRoomRow = data.currentRoomRow ?? CENTER_ROW;
            currentRoomCol = data.currentRoomCol ?? CENTER_COL;
            returnRoomRow = data.returnRoomRow ?? CENTER_ROW;
            returnRoomCol = data.returnRoomCol ?? CENTER_COL;
            hasKey = !!data.hasKey;
            inventory.clear();
            if (Array.isArray(data.inventory)) data.inventory.forEach(id => inventory.add(id));
            ballRoomCoord = data.ballRoomCoord || ballRoomCoord;
            plateRoomCoord = data.plateRoomCoord || plateRoomCoord;
            portalRoomCoord = data.portalRoomCoord || portalRoomCoord;
            if (data.themeMode) { themeMode = data.themeMode; updateThemeButtons(); }
            updateInventoryUI();
            recomputeTheme();
            if (currentMode === "maze") showMazeRoom(currentRoomRow, currentRoomCol, fromInit);
            else if (currentMode === "puzzle") loadPuzzleScene();
            else if (currentMode === "ending") loadEnding();
            else loadMenu();
        }

        function fullRestart() {
            try { ["slot1", "slot2", "slot3", AUTO_SLOT].forEach(slot => localStorage.removeItem(SAVE_PREFIX + slot)); } catch (e) {}
            currentMode = "menu"; currentRoomRow = CENTER_ROW; currentRoomCol = CENTER_COL; returnRoomRow = CENTER_ROW; returnRoomCol = CENTER_COL;
            hasKey = false; inventory.clear(); pendingLoadData = null;
            updateInventoryUI();
            showStatus("Game fully restarted.", 1200);
            loadMenu();
        }

        function refreshItemVisibility() {
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = mazeRooms[r][c];
                    g.children.forEach(obj => {
                        if (obj.userData && obj.userData.type === "item") obj.visible = !inventory.has(obj.userData.itemId);
                    });
                }
            }
        }

        function hideAllRooms() {
            for (let r = 0; r < NUM_ROWS; r++) { for (let c = 0; c < NUM_COLS; c++) mazeRooms[r][c].visible = false; }
            menuGroup.visible = false;
            puzzleGroup.visible = false;
            // Hide touch controls by default
            document.getElementById('touch-controls').style.display = 'none';
            document.getElementById('puzzle-restart-btn').style.display = 'none';
        }

        function loadMenu() {
            currentMode = "menu";
            hideAllRooms();
            menuGroup.visible = true;
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('start-text').style.display = 'block';
            document.getElementById('status-msg').style.display = 'none';
            camera = perspCamera;
            camera.position.set(0, 12, 15);
            camera.lookAt(0, 10, 0);
            cameraBasePosition.copy(camera.position);
            saveGame(AUTO_SLOT);
        }

        function showMazeRoom(row, col, skipSave = false) {
            currentMode = "maze";
            currentRoomRow = row;
            currentRoomCol = col;
            hideAllRooms();
            mazeRooms[row][col].visible = true;

            const instr = document.getElementById('instructions');
            document.getElementById('start-text').style.display = 'none';
            document.getElementById('status-msg').style.display = 'none';

            camera = orthoCamera;
            camera.position.set(0, 25, 0);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, -1);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'block';
            const isCenter = (row === CENTER_ROW && col === CENTER_COL);
            if (isCenter) {
                instr.innerHTML = `<h2>Central Room</h2><p>Find a <b>ball</b>, a <b>plate</b>, and a <b>locked portal</b>.</p>`;
            } else {
                instr.innerHTML = `<h2>Maze Room</h2><p>Tap objects to interact.</p>`;
            }
            if (!skipSave) saveGame(AUTO_SLOT);
        }

        function loadPuzzleScene() {
            currentMode = "puzzle";
            hideAllRooms();
            puzzleGroup.visible = true;
            
            // Show Touch Controls
            document.getElementById('touch-controls').style.display = 'flex';
            document.getElementById('puzzle-restart-btn').style.display = 'flex';

            const instr = document.getElementById('instructions');
            document.getElementById('start-text').style.display = 'none';
            document.getElementById('status-msg').style.display = 'none';

            camera = perspCamera;
            camera.position.set(0, 20, 25);
            camera.lookAt(0, 0, 0);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'block';
            instr.innerHTML = `<h2>Puzzle</h2><p>Tilt floor with D-Pad.</p>`;
            restartGame();
            saveGame(AUTO_SLOT);
        }

        function loadEnding() {
            currentMode = "ending";
            hideAllRooms();
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('start-text').style.display = 'none';
            camera = perspCamera;
            camera.position.set(0, 12, 15);
            camera.lookAt(0, 0, 0);
            cameraBasePosition.copy(camera.position);
            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'block';
            statusEl.className = 'win';
            statusEl.textContent = "ESCAPED!";
            showStatus("The labyrinth dissolves behind you...", 3000);
            saveGame(AUTO_SLOT);
        }

        function updateInventoryUI() {
            const invEl = document.getElementById('inventory-ui');
            if (invEl) invEl.textContent = inventory.size === 0 ? 'Inventory: (empty)' : 'Inventory: ' + Array.from(inventory).join(', ');
            refreshItemVisibility();
        }

        function showStatus(text, timeout = 2000) {
            const msgEl = document.getElementById('message');
            msgEl.textContent = text;
            msgEl.style.display = 'block';
            if (timeout > 0) {
                clearTimeout(showStatus._timeoutId);
                showStatus._timeoutId = setTimeout(() => { msgEl.style.display = 'none'; }, timeout);
            }
        }

        function onPointerDown(event) {
            // If we are clicking on UI, ignore 3D interaction logic
            if(event.target.closest('button') || event.target.closest('.dpad-btn') || event.target.id === 'puzzle-restart-btn') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            let clickable = [];
            if (currentMode === "menu") clickable = menuGroup.children;
            else if (currentMode === "maze") clickable = mazeRooms[currentRoomRow][currentRoomCol].children;
            else if (currentMode === "puzzle") clickable = puzzleGroup.children;
            else return;

            const hits = raycaster.intersectObjects(clickable, true);
            if (hits.length === 0) return;

            const obj = hits[0].object;

            if (currentMode === "menu" && obj.userData.type === "startGame") {
                showMazeRoom(CENTER_ROW, CENTER_COL);
                return;
            }

            if (currentMode === "maze") {
                if (obj.userData.type === "item") {
                    const id = obj.userData.itemId;
                    if (!inventory.has(id)) {
                        inventory.add(id);
                        updateInventoryUI();
                        showStatus("Picked up " + id + "!");
                    }
                    if (inventory.has("ball") && inventory.has("plate") && !hasKey) {
                        returnRoomRow = currentRoomRow;
                        returnRoomCol = currentRoomCol;
                        startScreenShake(0.45, 0.8);
                        showStatus("The floor trembles...", 2000);
                        saveGame(AUTO_SLOT);
                        setTimeout(() => { loadPuzzleScene(); }, 800);
                    } else {
                        saveGame(AUTO_SLOT);
                    }
                    return;
                }
                if (obj.userData.type === "door") {
                    const kind = obj.userData.kind || "mazeDoor";
                    if (kind === "mazeDoor") {
                        showMazeRoom(obj.userData.row, obj.userData.col);
                        return;
                    }
                    if (kind === "finalExit") {
                        if (!hasKey) showStatus("Sealed. Needs key.");
                        else { showStatus("Portal Opening..."); loadEnding(); }
                        return;
                    }
                }
            }
        }

        function restartGame() {
            if (!ballBody || !floorBody) return;
            gameActive = true;
            ballBody.position.set(-5, 5, -5);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);
            floorBody.quaternion.setFromEuler(0, 0, 0);
            document.getElementById('status-msg').style.display = 'none';
        }

        function updatePhysics() {
            if (currentMode !== "puzzle") return;
            if (!ballBody || !floorBody) return;

            if (gameActive) {
                const maxTilt = 0.3;
                const currentEuler = new CANNON.Vec3();
                floorBody.quaternion.toEuler(currentEuler);
                let targetX = 0;
                let targetZ = 0;
                if (keys.ArrowUp) targetX = -maxTilt;
                if (keys.ArrowDown) targetX = maxTilt;
                if (keys.ArrowLeft) targetZ = maxTilt;
                if (keys.ArrowRight) targetZ = -maxTilt;
                currentEuler.x += (targetX - currentEuler.x) * 0.05;
                currentEuler.z += (targetZ - currentEuler.z) * 0.05;
                floorBody.quaternion.setFromEuler(currentEuler.x, 0, currentEuler.z);
            }

            world.step(timeStep);
            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);
            floorMesh.position.copy(floorBody.position);
            floorMesh.quaternion.copy(floorBody.quaternion);

            if (gameActive) checkWinCondition();
        }

        function checkWinCondition() {
            if (ballBody.position.y < -10) endGame(false);
            const dx = ballBody.position.x - TARGET_POS.x;
            const dz = ballBody.position.z - TARGET_POS.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            if (dist < TARGET_RADIUS && ballBody.position.y > -1) endGame(true);
        }

        function endGame(isWin) {
            gameActive = false;
            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'block';
            if (isWin) {
                statusEl.textContent = "SUCCESS!";
                statusEl.className = 'win';
                if (!hasKey) {
                    hasKey = true;
                    inventory.add("key");
                    updateInventoryUI();
                    showStatus("Key Obtained!", 2500);
                }
                setTimeout(() => { showMazeRoom(returnRoomRow, returnRoomCol); }, 1500);
            } else {
                statusEl.textContent = "FAILURE";
                statusEl.className = 'lose';
                showStatus("Press Restart Button to retry.");
            }
            saveGame(AUTO_SLOT);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            orthoCamera.left = -viewSize * aspect;
            orthoCamera.right = viewSize * aspect;
            orthoCamera.top = viewSize;
            orthoCamera.bottom = -viewSize;
            orthoCamera.updateProjectionMatrix();
            perspCamera.aspect = aspect;
            perspCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateScreenShake();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
