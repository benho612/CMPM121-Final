<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>F2 Prototype: Gravity Escape Mobile</title>
    <style>
        :root {
            color-scheme: light dark;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #111; /* Default Dark Background */
            color: #fff;            /* Default Dark Text */
            touch-action: none; /* Prevent scroll on mobile */
            transition: background-color 0.3s, color 0.3s; /* Smooth transition */
        }

        /* RTL mode helper */
        body.rtl-mode {
            direction: rtl;
        }

        body.rtl-mode #instructions,
        body.rtl-mode #message,
        body.rtl-mode #status-msg,
        body.rtl-mode #inventory-ui {
            text-align: right;
        }

        /* --- Header Buttons --- */
        .header-btn {
            position: absolute;
            top: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 24px;
            user-select: none;
            color: white;
        }

        #gear-btn {
            right: 20px;
        }

        #puzzle-restart-btn {
            right: 70px; 
            display: none;
        }

        /* --- Expanded Menu --- */
        #expanded-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 90;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            backdrop-filter: blur(5px);
        }

        #expanded-menu.open {
            display: flex;
        }

        /* UI Containers */
        #inventory-ui, #save-ui, #theme-ui, #lang-ui {
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            width: 80%;
            max-width: 300px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 10px;
            color: inherit;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: inherit;
            pointer-events: none;
            z-index: 10;
            width: auto;
        }

        #instructions {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            max-width: 340px;
            color: inherit;
        }
        
        #status-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            display: none;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
            z-index: 20;
            white-space: pre-line;
            pointer-events: none;
            width: 90%;
        }
        .win { color: #4ade80; }
        .lose { color: #f87171; }

        #start-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        #message {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            color: inherit;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 16px;
            display: none;
            z-index: 15;
            pointer-events: none;
            width: max-content;
            max-width: 90%;
            text-align: center;
        }

        /* UI Element Styling */
        #save-ui span, #theme-ui span, #lang-ui span {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        #save-ui button, #theme-ui button, #lang-ui button {
            padding: 8px;
            margin: 2px;
            font-size: 14px;
            cursor: pointer;
        }
        
        #theme-ui, #lang-ui {
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
        }

        #theme-ui button.active,
        #lang-ui button.active {
            border: 2px solid #4ade80;
        }

        /* --- Joystick Controls (Default / Dark Mode) --- */
        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 140px;
            /* Light rings for dark background */
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 50;
            display: none;
            touch-action: none;
        }
        
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            /* Light knob for dark background */
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* --- Mobile Styles --- */
        @media (max-width: 768px) {
            #ui-layer {
                top: 70px;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                display: flex;
                justify-content: center;
            }

            #instructions {
                font-size: 12px;
                padding: 8px;
                max-width: 100%;
                text-align: center;
                background: rgba(0, 0, 0, 0.4);
            }

            #instructions h2 {
                font-size: 14px;
                margin: 0 0 5px 0;
            }
            
            #message {
                bottom: 180px;
                font-size: 14px;
            }
            
            #status-msg {
                font-size: 28px;
            }
        }

        /* --- LIGHT MODE OVERRIDES (Applied via JS Class) --- */
        body.light-mode {
            background-color: #dbeafe;
            color: #111827;
        }

        body.light-mode #instructions {
            background: rgba(255, 255, 255, 0.9);
            color: #111827;
        }

        /* Mobile instruction override for light mode */
        @media (max-width: 768px) {
            body.light-mode #instructions {
                background: rgba(255, 255, 255, 0.7);
            }
        }

        body.light-mode .header-btn {
            background: rgba(255, 255, 255, 0.8);
            border-color: #111827;
            color: #111827;
        }
        
        body.light-mode #expanded-menu {
            background: rgba(255, 255, 255, 0.95);
            color: #111827;
        }

        body.light-mode #inventory-ui, 
        body.light-mode #save-ui, 
        body.light-mode #theme-ui,
        body.light-mode #lang-ui {
            background: rgba(0, 0, 0, 0.05);
            color: #111827;
        }

        body.light-mode #message {
            background: rgba(15, 23, 42, 0.9);
            color: #e5e7eb;
        }
        
        /* Joystick Dark Colors for Light Background */
        body.light-mode #joystick-zone {
            border-color: rgba(0,0,0,0.3);
            background: rgba(0,0,0,0.05);
        }
        body.light-mode #joystick-knob {
            background: rgba(0,0,0,0.5);
        }

        body.light-mode #start-text {
            color: #111827;
            text-shadow: 2px 2px 4px #ffffff88;
        }

    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="gear-btn" class="header-btn">⚙</div>
    <div id="puzzle-restart-btn" class="header-btn">↻</div>

    <div id="expanded-menu">
        <h2>PAUSE / MENU</h2>
        <div id="inventory-ui">Inventory: (empty)</div>
        
        <div id="save-ui">
            <span>Saves:</span>
            <div>
                <button data-slot="slot1" data-action="save">Save 1</button>
                <button data-slot="slot1" data-action="load">Load 1</button>
            </div>
            <div>
                <button data-slot="slot2" data-action="save">Save 2</button>
                <button data-slot="slot2" data-action="load">Load 2</button>
            </div>
            <div>
                <button data-slot="slot3" data-action="save">Save 3</button>
                <button data-slot="slot3" data-action="load">Load 3</button>
            </div>
            <div style="margin-top:10px;">
                <button data-slot="restart" data-action="restart" style="background:#f87171; color:white; border:none;">Restart Run</button>
            </div>
        </div>

        <div id="theme-ui">
            <span style="width:100%">Theme:</span>
            <button data-theme="system" class="active">System</button>
            <button data-theme="light">Light</button>
            <button data-theme="dark">Dark</button>
        </div>

        <div id="lang-ui">
            <span style="width:100%">Language:</span>
            <button data-lang="en" class="active">EN</button>
            <button data-lang="zh">中文</button>
            <button data-lang="ar">العربية</button>
        </div>
        
        <button id="close-menu-btn" style="padding:10px 20px; font-size:16px; cursor:pointer;">Resume Game</button>
    </div>

    <div id="ui-layer">
        <div id="instructions"></div>
    </div>

    <div id="status-msg"></div>
    <div id="message"></div>
    <div id="start-text">START GAME ↓</div>
    
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, renderer;
        let world;
        const timeStep = 1 / 60;

        // Mobile Detection
        const isMobileDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Cameras
        let perspCamera, orthoCamera, camera;
        let viewSize = 15; // Base view size

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Modes: menu | maze | puzzle | ending
        let currentMode = "menu";

        // Language: 'en' | 'zh' | 'ar'
        let currentLang = 'en';

        // Maze rooms: 3x3
        const NUM_ROWS = 3;
        const NUM_COLS = 3;
        const CENTER_ROW = 1;
        const CENTER_COL = 1;
        const mazeRooms = [];
        let currentRoomRow = CENTER_ROW;
        let currentRoomCol = CENTER_COL;

        // When entering puzzle, remember which room we came from
        let returnRoomRow = CENTER_ROW;
        let returnRoomCol = CENTER_COL;

        // Screen shake state
        let shakeTime = 0;
        let shakeDuration = 0;
        let shakeIntensity = 0;
        const cameraBasePosition = new THREE.Vector3();

        // Lighting and theme
        let ambientLight;
        let dirLight;
        let hemiLight;
        let themeMode = "system"; // system | light | dark
        let systemPrefersDark = false;

        // Materials that respond to theme
        const mazeFloorMats = [];
        const mazeWallMats = [];
        let puzzleFloorMat = null;

        // Groups for non-maze scenes
        let menuGroup;
        let puzzleGroup;

        // Physics objects (puzzle)
        let ballMesh, ballBody;
        let floorMesh, floorBody;
        let targetMesh;

        // Game state / inventory
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const TARGET_POS = { x: 8, z: 8 };
        const TARGET_RADIUS = 1.5;

        const inventory = new Set();
        let hasKey = false;
        let gameActive = false;

        // Random placement
        let ballRoomCoord = null;
        let plateRoomCoord = null;
        let portalRoomCoord = null;

        // --- Save system globals ---
        const SAVE_PREFIX = "gravityEscape_";
        const AUTO_SLOT = "autosave";
        let pendingLoadData = null;

        try {
            const raw = localStorage.getItem(SAVE_PREFIX + AUTO_SLOT);
            if (raw) {
                pendingLoadData = JSON.parse(raw);
                if (pendingLoadData && typeof pendingLoadData === "object") {
                    currentMode = pendingLoadData.currentMode || "maze";
                    currentRoomRow = pendingLoadData.currentRoomRow ?? CENTER_ROW;
                    currentRoomCol = pendingLoadData.currentRoomCol ?? CENTER_COL;
                    returnRoomRow = pendingLoadData.returnRoomRow ?? CENTER_ROW;
                    returnRoomCol = pendingLoadData.returnRoomCol ?? CENTER_COL;
                    hasKey = !!pendingLoadData.hasKey;

                    if (Array.isArray(pendingLoadData.inventory)) {
                        pendingLoadData.inventory.forEach(id => inventory.add(id));
                    }

                    ballRoomCoord = pendingLoadData.ballRoomCoord || null;
                    plateRoomCoord = pendingLoadData.plateRoomCoord || null;
                    portalRoomCoord = pendingLoadData.portalRoomCoord || null;

                    if (pendingLoadData.themeMode) {
                        themeMode = pendingLoadData.themeMode;
                    }
                    if (pendingLoadData.lang) {
                        currentLang = pendingLoadData.lang;
                    }
                }
            }
        } catch (e) {
            console.warn("Failed to parse autosave:", e);
            pendingLoadData = null;
        }

        init();
        animate();

        function init() {
            // THREE.js setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202025);
            scene.fog = new THREE.Fog(0x202025, 30, 150); 

            const aspect = window.innerWidth / window.innerHeight;
            const isPortrait = aspect < 1.0;

            // Orthographic Camera (Maze): Adjusted for zoom scale
            let effectiveViewSize = viewSize;
            if (isPortrait) {
                effectiveViewSize = viewSize * 1.5;
            }

            // Perspective Camera (Puzzle/Menu): Adjusted for zoom scale
            const camDist = isPortrait ? 45 : 25;
            const camHeight = isPortrait ? 35 : 20;

            perspCamera = new THREE.PerspectiveCamera(
                45,
                aspect,
                0.1,
                200
            );
            perspCamera.position.set(0, camHeight, camDist);
            perspCamera.lookAt(0, 0, 0);

            // Orthographic camera
            orthoCamera = new THREE.OrthographicCamera(
                -effectiveViewSize * aspect,
                effectiveViewSize * aspect,
                effectiveViewSize,
                -effectiveViewSize,
                0.1,
                100
            );
            orthoCamera.position.set(0, 25, 0);
            orthoCamera.lookAt(0, 0, 0);
            orthoCamera.up.set(0, 0, -1);

            camera = perspCamera;
            cameraBasePosition.copy(camera.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // --- Lighting Setup ---
            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemiLight);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            // CANNON World
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0)
            });

            const physicsMaterial = new CANNON.Material('physics');
            const physicsContactMaterial = new CANNON.ContactMaterial(
                physicsMaterial,
                physicsMaterial,
                { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(physicsContactMaterial);

            // Groups
            menuGroup = new THREE.Group();
            scene.add(menuGroup);

            // Maze rooms groups
            for (let r = 0; r < NUM_ROWS; r++) {
                mazeRooms[r] = [];
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = new THREE.Group();
                    mazeRooms[r][c] = g;
                    scene.add(g);
                }
            }

            puzzleGroup = new THREE.Group();
            scene.add(puzzleGroup);

            // --- MENU ---
            {
                const startButtonGeo = new THREE.PlaneGeometry(6, 2);
                const startButtonMat = new THREE.MeshBasicMaterial({
                    color: 0x44ff88,
                    side: THREE.DoubleSide
                });
                const startButton = new THREE.Mesh(startButtonGeo, startButtonMat);
                startButton.position.set(0, 10, 0);
                startButton.rotation.x = -Math.PI / 4;
                startButton.userData.type = "startGame";
                menuGroup.add(startButton);
            }

            // Helper: build basic room
            function buildBasicRoom(group) {
                const floorGeo = new THREE.BoxGeometry(12, 1, 12);
                const floorMat = new THREE.MeshStandardMaterial({ color: 0x444466 });
                mazeFloorMats.push(floorMat);
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.receiveShadow = true;
                floor.position.y = 0;
                group.add(floor);

                const wallGeoZ = new THREE.BoxGeometry(12, 1.2, 0.5);
                const wallGeoX = new THREE.BoxGeometry(0.5, 1.2, 12);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x222233 });
                mazeWallMats.push(wallMat);

                const backWall = new THREE.Mesh(wallGeoZ, wallMat);
                backWall.position.set(0, 0.6, -6);
                group.add(backWall);

                const frontWall = new THREE.Mesh(wallGeoZ, wallMat);
                frontWall.position.set(0, 0.6, 6);
                group.add(frontWall);

                const leftWall = new THREE.Mesh(wallGeoX, wallMat);
                leftWall.position.set(-6, 0.6, 0);
                group.add(leftWall);

                const rightWall = new THREE.Mesh(wallGeoX, wallMat);
                rightWall.position.set(6, 0.6, 0);
                group.add(rightWall);
            }

            // Build all maze rooms (geometry only)
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    buildBasicRoom(mazeRooms[r][c]);
                }
            }

            // Add doors between adjacent rooms
            const doorGeo = new THREE.BoxGeometry(2, 3, 0.5);
            const doorMatMaze = new THREE.MeshStandardMaterial({ color: 0x64748b });

            function addMazeDoor(group, direction, targetRow, targetCol) {
                const door = new THREE.Mesh(doorGeo, doorMatMaze);
                door.userData.type = "door";
                door.userData.kind = "mazeDoor";
                door.userData.row = targetRow;
                door.userData.col = targetCol;

                if (direction === "north") {
                    door.position.set(0, 1.5, -5.75);
                } else if (direction === "south") {
                    door.position.set(0, 1.5, 5.75);
                } else if (direction === "west") {
                    door.rotation.y = Math.PI / 2;
                    door.position.set(-5.75, 1.5, 0);
                } else if (direction === "east") {
                    door.rotation.y = Math.PI / 2;
                    door.position.set(5.75, 1.5, 0);
                }

                group.add(door);
            }

            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = mazeRooms[r][c];
                    if (r > 0) addMazeDoor(g, "north", r - 1, c);
                    if (r < NUM_ROWS - 1) addMazeDoor(g, "south", r + 1, c);
                    if (c > 0) addMazeDoor(g, "west", r, c - 1);
                    if (c < NUM_COLS - 1) addMazeDoor(g, "east", r, c + 1);
                }
            }

            // --- Random placement of ball / plate / portal ---
            if (!ballRoomCoord || !plateRoomCoord || !portalRoomCoord) {
                const coords = [];
                for (let r = 0; r < NUM_ROWS; r++) {
                    for (let c = 0; c < NUM_COLS; c++) {
                        if (r === CENTER_ROW && c === CENTER_COL) continue;
                        coords.push({ r, c });
                    }
                }
                shuffleArray(coords);
                if (!ballRoomCoord) ballRoomCoord = coords[0];
                if (!plateRoomCoord) plateRoomCoord = coords[1];
                if (!portalRoomCoord) portalRoomCoord = coords[2];
            }

            // Place ball
            {
                const { r, c } = ballRoomCoord;
                const group = mazeRooms[r][c];
                const ballGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4b4b });
                const ball = new THREE.Mesh(ballGeo, ballMat);
                ball.position.set(0, 1, 0);
                ball.castShadow = true;
                ball.userData.type = "item";
                ball.userData.itemId = "ball";
                group.add(ball);
            }

            // Place plate
            {
                const { r, c } = plateRoomCoord;
                const group = mazeRooms[r][c];
                const plateGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.2, 32);
                const plateMat = new THREE.MeshStandardMaterial({ color: 0x4ade80 });
                const plate = new THREE.Mesh(plateGeo, plateMat);
                plate.position.set(0, 1, 0);
                plate.castShadow = true;
                plate.userData.type = "item";
                plate.userData.itemId = "plate";
                group.add(plate);
            }

            // Place locked portal door in portalRoom on an outer wall
            {
                const { r, c } = portalRoomCoord;
                const group = mazeRooms[r][c];
                const portalGeo = new THREE.BoxGeometry(2, 3, 0.5);
                const portalMat = new THREE.MeshStandardMaterial({ color: 0x8b5cf6 });

                const portalDoor = new THREE.Mesh(portalGeo, portalMat);
                portalDoor.userData.type = "door";
                portalDoor.userData.kind = "finalExit";
                portalDoor.userData.target = "ending";

                if (r === 0) {
                    portalDoor.position.set(0, 1.5, -5.75);
                } else if (r === NUM_ROWS - 1) {
                    portalDoor.position.set(0, 1.5, 5.75);
                } else if (c === 0) {
                    portalDoor.rotation.y = Math.PI / 2;
                    portalDoor.position.set(-5.75, 1.5, 0);
                } else {
                    portalDoor.rotation.y = Math.PI / 2;
                    portalDoor.position.set(5.75, 1.5, 0);
                }

                group.add(portalDoor);
            }

            // --- PUZZLE ROOM (physics puzzle) ---
            {
                const floorGeoB = new THREE.BoxGeometry(20, 1, 20);
                const floorMatB = new THREE.MeshStandardMaterial({ color: 0x666644 });
                puzzleFloorMat = floorMatB;
                floorMesh = new THREE.Mesh(floorGeoB, floorMatB);
                floorMesh.receiveShadow = true;
                puzzleGroup.add(floorMesh);

                const floorShape = new CANNON.Box(new CANNON.Vec3(10, 0.5, 10));
                floorBody = new CANNON.Body({
                    mass: 0,
                    type: CANNON.Body.KINEMATIC,
                    material: physicsMaterial
                });
                floorBody.addShape(floorShape);
                world.addBody(floorBody);

                const ballRadius = 0.8;
                const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 });
                ballMesh = new THREE.Mesh(ballGeo, ballMat);
                ballMesh.castShadow = true;
                puzzleGroup.add(ballMesh);

                const ballShape = new CANNON.Sphere(ballRadius);
                ballBody = new CANNON.Body({
                    mass: 5,
                    shape: ballShape,
                    material: physicsMaterial
                });
                ballBody.position.set(-5, 5, -5);
                ballBody.linearDamping = 0.1;
                world.addBody(ballBody);

                const targetGeo = new THREE.CylinderGeometry(
                    TARGET_RADIUS,
                    TARGET_RADIUS,
                    0.1,
                    32
                );
                const targetMat = new THREE.MeshBasicMaterial({
                    color: 0x4ade80,
                    opacity: 0.5,
                    transparent: true
                });
                targetMesh = new THREE.Mesh(targetGeo, targetMat);
                targetMesh.position.set(TARGET_POS.x, 0.6, TARGET_POS.z);
                floorMesh.add(targetMesh);
            }

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
                if (e.key.toLowerCase() === 'r') restartGame();
            });
            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            });

            // Setup UI and Joystick
            setupUIInteractions();
            setupJoystick();

            // Auto-save on tab close
            window.addEventListener('beforeunload', () => {
                saveGame(AUTO_SLOT);
            });

            updateInventoryUI();

            // Set up theme from system preference
            setupThemeFromSystem();

            // Apply language-dependent static UI
            refreshLanguageStaticUI();

            // Apply autosave if present, otherwise start at menu
            if (pendingLoadData) {
                applyLoadedData(pendingLoadData, true);
            } else {
                loadMenu();
            }
        }

        // --- New UI & Joystick Logic ---
        function setupUIInteractions() {
            const gearBtn = document.getElementById('gear-btn');
            const restartBtn = document.getElementById('puzzle-restart-btn');
            const menu = document.getElementById('expanded-menu');
            const closeBtn = document.getElementById('close-menu-btn');
            const saveUI = document.getElementById('save-ui');
            const themeUI = document.getElementById('theme-ui');
            const langUI = document.getElementById('lang-ui');

            // Toggle Menu
            function toggleMenu() {
                menu.classList.toggle('open');
            }

            gearBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleMenu();
            });

            // Restart Puzzle Button
            restartBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if(currentMode === "puzzle") {
                    restartGame();
                }
            });

            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                menu.classList.remove('open');
            });

            // Save Handlers
            saveUI.addEventListener('click', (e) => {
                const btn = e.target;
                if (!(btn instanceof HTMLButtonElement)) return;
                const slot = btn.dataset.slot;
                const action = btn.dataset.action;
                if (!action) return;

                e.stopPropagation();

                if (action === 'save' || action === 'load') {
                    if (!slot) return;
                    if (action === 'save') {
                        saveGame(slot);
                        let msg;
                        if (currentLang === 'en') {
                            msg = "Saved to " + slot.toUpperCase();
                        } else if (currentLang === 'zh') {
                            msg = "已保存到 " + slot.toUpperCase();
                        } else {
                            msg = "تم الحفظ في " + slot.toUpperCase();
                        }
                        showStatus(msg, 1000);
                    } else if (action === 'load') {
                        loadGame(slot);
                        toggleMenu();
                    }
                } else if (action === 'restart') {
                    fullRestart();
                    toggleMenu();
                }
            });

            // Theme Handlers
            themeUI.addEventListener('click', (e) => {
                const btn = e.target;
                if (!(btn instanceof HTMLButtonElement)) return;
                const mode = btn.dataset.theme;
                if (!mode) return;
                e.stopPropagation();

                themeMode = mode;
                updateThemeButtons();
                recomputeTheme();
                saveGame(AUTO_SLOT);
            });
            updateThemeButtons();

            // Language Handlers
            langUI.addEventListener('click', (e) => {
                const btn = e.target;
                if (!(btn instanceof HTMLButtonElement)) return;
                const lang = btn.dataset.lang;
                if (!lang) return;
                e.stopPropagation();

                currentLang = lang;
                updateLangButtons();
                refreshLanguageStaticUI();
                refreshLanguageForCurrentMode();
                saveGame(AUTO_SLOT);
            });
            updateLangButtons();
        }

        function setupJoystick() {
            const zone = document.getElementById('joystick-zone');
            const knob = document.getElementById('joystick-knob');
            let startX = 0, startY = 0;
            let isDragging = false;
            const maxDist = 35;

            zone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = true;
                const touch = e.touches[0];
                const rect = zone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                startX = centerX;
                startY = centerY;
                
                updateJoystick(touch.clientX, touch.clientY);
            }, { passive: false });

            zone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging) return;
                const touch = e.touches[0];
                updateJoystick(touch.clientX, touch.clientY);
            }, { passive: false });

            const endDrag = () => {
                if (!isDragging) return;
                isDragging = false;
                knob.style.transform = `translate(-50%, -50%)`;
                keys.ArrowUp = false;
                keys.ArrowDown = false;
                keys.ArrowLeft = false;
                keys.ArrowRight = false;
            };

            zone.addEventListener('touchend', endDrag);
            zone.addEventListener('touchcancel', endDrag);

            function updateJoystick(clientX, clientY) {
                let dx = clientX - startX;
                let dy = clientY - startY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist > maxDist) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxDist;
                    dy = Math.sin(angle) * maxDist;
                }

                knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                const threshold = 10;
                keys.ArrowRight = dx > threshold;
                keys.ArrowLeft = dx < -threshold;
                keys.ArrowDown = dy > threshold;
                keys.ArrowUp = dy < -threshold;
            }
        }

        // --- Utility: shuffle array ---
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        // --- Screen shake helpers ---
        function startScreenShake(duration = 0.4, intensity = 0.6) {
            shakeDuration = duration;
            shakeTime = duration;
            shakeIntensity = intensity;
            cameraBasePosition.copy(camera.position);
        }

        function updateScreenShake() {
            if (shakeTime <= 0) return;

            const progress = 1 - shakeTime / shakeDuration;
            const damper = 1 - progress;

            const offsetX = (Math.random() - 0.5) * 2 * shakeIntensity * damper;
            const offsetY = (Math.random() - 0.5) * 2 * shakeIntensity * damper;

            camera.position.set(
                cameraBasePosition.x + offsetX,
                cameraBasePosition.y + offsetY,
                cameraBasePosition.z
            );

            shakeTime -= timeStep;
            if (shakeTime <= 0) {
                camera.position.copy(cameraBasePosition);
            }
        }

        // --- Visual theme helpers (light/dark) ---
        function applyTheme(mode) {
            if (mode === 'light') {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }

            if (!scene || !ambientLight || !dirLight) return;

            if (mode === "dark") {
                scene.background.set(0x050816);
                scene.fog.color.set(0x050816);
                ambientLight.intensity = 1.2; 
                dirLight.intensity = 2.0;     
                dirLight.color.set(0xbfd7ff);

                mazeFloorMats.forEach(m => {
                    m.color.set(0x1e293b);
                    m.roughness = 0.9;
                    m.metalness = 0.0;
                });
                mazeWallMats.forEach(m => {
                    m.color.set(0x020617);
                    m.roughness = 0.9;
                    m.metalness = 0.0;
                });
                if (puzzleFloorMat) {
                    puzzleFloorMat.color.set(0x5c6b7f); 
                    puzzleFloorMat.roughness = 0.7;
                    puzzleFloorMat.metalness = 0.1;
                }
            } else {
                scene.background.set(0xcbe5ff);
                scene.fog.color.set(0xcbe5ff);
                ambientLight.intensity = 1.0; 
                dirLight.intensity = 1.2;     
                dirLight.color.set(0xfff2cf);

                mazeFloorMats.forEach(m => {
                    m.color.set(0xe2e8f0);
                    m.roughness = 0.6;
                    m.metalness = 0.1;
                });
                mazeWallMats.forEach(m => {
                    m.color.set(0xf8fafc);
                    m.roughness = 0.7;
                    m.metalness = 0.0;
                });
                if (puzzleFloorMat) {
                    puzzleFloorMat.color.set(0xfacc6b);
                    puzzleFloorMat.roughness = 0.7;
                    puzzleFloorMat.metalness = 0.1;
                }
            }
            renderer.setClearColor(scene.background);
        }

        function recomputeTheme() {
            const effective = themeMode === "light" || themeMode === "dark"
                ? themeMode
                : (systemPrefersDark ? "dark" : "light");
            applyTheme(effective);
        }

        function setupThemeFromSystem() {
            if (window.matchMedia) {
                const mq = window.matchMedia("(prefers-color-scheme: dark)");
                systemPrefersDark = mq.matches;
                recomputeTheme();

                if (mq.addEventListener) {
                    mq.addEventListener("change", (e) => {
                        systemPrefersDark = e.matches;
                        if (themeMode === "system") {
                            recomputeTheme();
                        }
                    });
                } else if (mq.addListener) {
                    mq.addListener((e) => {
                        systemPrefersDark = e.matches;
                        if (themeMode === "system") {
                            recomputeTheme();
                        }
                    });
                }
            } else {
                systemPrefersDark = false;
                recomputeTheme();
            }
        }

        function updateThemeButtons() {
            const themeUI = document.getElementById('theme-ui');
            const buttons = themeUI.querySelectorAll('button[data-theme]');
            buttons.forEach(btn => {
                if (btn.dataset.theme === themeMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function updateLangButtons() {
            const langUI = document.getElementById('lang-ui');
            const buttons = langUI.querySelectorAll('button[data-lang]');
            buttons.forEach(btn => {
                if (btn.dataset.lang === currentLang) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        function applyDirForLang() {
            if (currentLang === 'ar') {
                document.body.dir = 'rtl';
                document.body.classList.add('rtl-mode');
            } else {
                document.body.dir = 'ltr';
                document.body.classList.remove('rtl-mode');
            }
        }

        // --- Item display name helper ---
        function getItemDisplayName(id) {
            if (currentLang === 'en') {
                if (id === 'ball') return 'ball';
                if (id === 'plate') return 'plate';
                if (id === 'key') return 'key';
                return id;
            } else if (currentLang === 'zh') {
                if (id === 'ball') return '球';
                if (id === 'plate') return '盘子';
                if (id === 'key') return '钥匙';
                return id;
            } else {
                if (id === 'ball') return 'كرة';
                if (id === 'plate') return 'صحن';
                if (id === 'key') return 'مفتاح';
                return id;
            }
        }

        // --- Save system helpers ---
        function buildSaveData() {
            return {
                version: 4,
                currentMode,
                currentRoomRow,
                currentRoomCol,
                returnRoomRow,
                returnRoomCol,
                hasKey,
                inventory: Array.from(inventory),
                ballRoomCoord,
                plateRoomCoord,
                portalRoomCoord,
                themeMode,
                lang: currentLang
            };
        }

        function saveGame(slot = AUTO_SLOT) {
            try {
                const key = SAVE_PREFIX + slot;
                localStorage.setItem(key, JSON.stringify(buildSaveData()));
            } catch (e) {
                console.warn("Save failed:", e);
            }
        }

        function loadGame(slot) {
            try {
                const key = SAVE_PREFIX + slot;
                const raw = localStorage.getItem(key);
                if (!raw) {
                    let msg;
                    if (currentLang === 'en') {
                        msg = "No save in " + slot.toUpperCase();
                    } else if (currentLang === 'zh') {
                        msg = "没有找到存档 " + slot.toUpperCase();
                    } else {
                        msg = "لا يوجد حفظ في " + slot.toUpperCase();
                    }
                    showStatus(msg, 1500);
                    return;
                }
                const data = JSON.parse(raw);
                applyLoadedData(data, false);
                let msg;
                if (currentLang === 'en') {
                    msg = "Loaded " + slot.toUpperCase();
                } else if (currentLang === 'zh') {
                    msg = "已读取 " + slot.toUpperCase();
                } else {
                    msg = "تم تحميل " + slot.toUpperCase();
                }
                showStatus(msg, 1000);
            } catch (e) {
                console.warn("Load failed:", e);
            }
        }

        function applyLoadedData(data, fromInit) {
            if (!data || typeof data !== "object") return;
            pendingLoadData = data;

            currentMode = data.currentMode || "maze";
            currentRoomRow = data.currentRoomRow ?? CENTER_ROW;
            currentRoomCol = data.currentRoomCol ?? CENTER_COL;
            returnRoomRow = data.returnRoomRow ?? CENTER_ROW;
            returnRoomCol = data.returnRoomCol ?? CENTER_COL;
            hasKey = !!data.hasKey;

            inventory.clear();
            if (Array.isArray(data.inventory)) {
                data.inventory.forEach(id => inventory.add(id));
            }

            ballRoomCoord = data.ballRoomCoord || ballRoomCoord;
            plateRoomCoord = data.plateRoomCoord || plateRoomCoord;
            portalRoomCoord = data.portalRoomCoord || portalRoomCoord;

            if (data.themeMode) {
                themeMode = data.themeMode;
                updateThemeButtons();
            }
            if (data.lang) {
                currentLang = data.lang;
                updateLangButtons();
                refreshLanguageStaticUI();
            }

            updateInventoryUI();

            recomputeTheme();

            if (currentMode === "maze") {
                showMazeRoom(currentRoomRow, currentRoomCol, fromInit);
            } else if (currentMode === "puzzle") {
                loadPuzzleScene();
            } else if (currentMode === "ending") {
                loadEnding();
            } else {
                loadMenu();
            }
        }

        // --- Full game restart ---
        function fullRestart() {
            try {
                ["slot1", "slot2", "slot3", AUTO_SLOT].forEach(slot => {
                    localStorage.removeItem(SAVE_PREFIX + slot);
                });
            } catch (e) {
                console.warn("Failed to clear saves:", e);
            }

            currentMode = "menu";
            currentRoomRow = CENTER_ROW;
            currentRoomCol = CENTER_COL;
            returnRoomRow = CENTER_ROW;
            returnRoomCol = CENTER_COL;
            hasKey = false;
            inventory.clear();
            pendingLoadData = null;

            updateInventoryUI();
            let msg;
            if (currentLang === 'en') {
                msg = "Game fully restarted.";
            } else if (currentLang === 'zh') {
                msg = "已重新开始一轮游戏。";
            } else {
                msg = "تمت إعادة تعيين اللعبة بالكامل.";
            }
            showStatus(msg, 1200);

            loadMenu();
        }

        // --- Scene helpers ---
        function refreshItemVisibility() {
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = mazeRooms[r][c];
                    g.children.forEach(obj => {
                        if (obj.userData && obj.userData.type === "item") {
                            const id = obj.userData.itemId;
                            obj.visible = !inventory.has(id);
                        }
                    });
                }
            }
        }

        function hideAllRooms() {
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    mazeRooms[r][c].visible = false;
                }
            }
            menuGroup.visible = false;
            puzzleGroup.visible = false;
        }

        function toggleJoystick(visible) {
            const joy = document.getElementById('joystick-zone');
            joy.style.display = (visible && isMobileDevice) ? 'block' : 'none';
        }

        function loadMenu() {
            currentMode = "menu";
            hideAllRooms();
            toggleJoystick(false);
            menuGroup.visible = true;
            
            document.getElementById('puzzle-restart-btn').style.display = 'none';

            const instr = document.getElementById('instructions');
            const startText = document.getElementById('start-text');
            const statusEl = document.getElementById('status-msg');

            statusEl.style.display = 'none';
            statusEl.className = '';

            const aspect = window.innerWidth / window.innerHeight;
            const isPortrait = aspect < 1.0;
            const camDist = isPortrait ? 30 : 15;

            camera = perspCamera;
            camera.position.set(0, 12, camDist);
            camera.lookAt(0, 10, 0);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'none';
            startText.style.display = 'block';
            if (currentLang === 'en') {
                startText.textContent = 'START GAME ↓';
            } else if (currentLang === 'zh') {
                startText.textContent = '开始游戏 ↓';
            } else {
                startText.textContent = 'ابدأ اللعبة ↓';
            }

            saveGame(AUTO_SLOT);
        }

        function showMazeRoom(row, col, skipSave = false) {
            currentMode = "maze";
            currentRoomRow = row;
            currentRoomCol = col;

            hideAllRooms();
            toggleJoystick(false);
            mazeRooms[row][col].visible = true;
            
            document.getElementById('puzzle-restart-btn').style.display = 'none';

            const instr = document.getElementById('instructions');
            const startText = document.getElementById('start-text');
            const statusEl = document.getElementById('status-msg');

            startText.style.display = 'none';
            statusEl.style.display = 'none';
            statusEl.className = '';

            camera = orthoCamera;
            camera.position.set(0, 25, 0);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, -1);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'block';

            const isCenter = (row === CENTER_ROW && col === CENTER_COL);

            if (isCenter) {
                if (currentLang === 'en') {
                    instr.innerHTML = `
                        <h2>Central Room</h2>
                        <p>You are in the <b>center</b> of a 3×3 maze.</p>
                        <p>Find a <b>ball</b>, a <b>plate</b>, and a <b>locked portal</b>.</p>
                        <p>Collect both items to be dragged into a gravity puzzle.</p>
                        <p>Beat the puzzle to earn a <b>key</b>, then find the portal room and escape.</p>
                    `;
                } else if (currentLang === 'zh') {
                    instr.innerHTML = `
                        <h2>中央房间</h2>
                        <p>你现在在一个 <b>3×3</b> 迷宫的<b>中心</b>。</p>
                        <p>找到一个<b>球</b>、一个<b>盘子</b>，以及一扇<b>被锁住的传送门</b>。</p>
                        <p>收集两个道具后，你会被拖入重力谜题房间。</p>
                        <p>解开谜题获得<b>钥匙</b>，再回到传送门房间逃离迷宫。</p>
                    `;
                } else {
                    instr.innerHTML = `
                        <h2>الغرفة المركزية</h2>
                        <p>أنت الآن في <b>منتصف</b> متاهة بحجم <b>٣×٣</b>.</p>
                        <p>ابحث عن <b>كرة</b> و<b>صحن</b> و<b>بوابة مقفلة</b>.</p>
                        <p>بعد جمع الغرضين، سيتم سحبك إلى غرفة لغز الجاذبية.</p>
                        <p>إنهاء اللغز يعطيك <b>مفتاحًا</b>، ثم اعثر على غرفة البوابة للهروب.</p>
                    `;
                }
            } else {
                if (currentLang === 'en') {
                    instr.innerHTML = `
                        <h2>Maze Room</h2>
                        <p>This is one of the nine rooms in the maze.</p>
                        <p>Click objects to interact, and doors to move to adjacent rooms.</p>
                        <p>You need a <b>ball</b>, a <b>plate</b>, then the puzzle key to open the portal.</p>
                    `;
                } else if (currentLang === 'zh') {
                    instr.innerHTML = `
                        <h2>迷宫房间</h2>
                        <p>这是迷宫中的九个房间之一。</p>
                        <p>点击物体可以互动，点击门可以前往相邻房间。</p>
                        <p>你需要找到<b>球</b>和<b>盘子</b>，再通过谜题获得钥匙，才能打开传送门。</p>
                    `;
                } else {
                    instr.innerHTML = `
                        <h2>غرفة في المتاهة</h2>
                        <p>هذه واحدة من الغرف التسع في المتاهة.</p>
                        <p>انقر على الأشياء للتفاعل، وعلى الأبواب للانتقال إلى الغرف المجاورة.</p>
                        <p>تحتاج إلى <b>كرة</b> و<b>صحن</b> ثم مفتاح اللغز لفتح البوابة.</p>
                    `;
                }
            }

            if (!skipSave) {
                saveGame(AUTO_SLOT);
            }
        }

        function loadPuzzleScene() {
            currentMode = "puzzle";
            hideAllRooms();
            toggleJoystick(true);
            puzzleGroup.visible = true;
            
            document.getElementById('puzzle-restart-btn').style.display = 'flex';

            const instr = document.getElementById('instructions');
            const startText = document.getElementById('start-text');
            const statusEl = document.getElementById('status-msg');

            startText.style.display = 'none';
            statusEl.style.display = 'none';
            statusEl.className = '';

            const aspect = window.innerWidth / window.innerHeight;
            const isPortrait = aspect < 1.0;
            const puzzleCamDist = isPortrait ? 45 : 25;
            const puzzleCamHeight = isPortrait ? 35 : 20;

            camera = perspCamera;
            camera.position.set(0, puzzleCamHeight, puzzleCamDist);
            camera.lookAt(0, 0, 0);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'block';
            if (currentLang === 'en') {
                instr.innerHTML = `
                    <h2>Gravity Puzzle Room</h2>
                    <p>Use <b>Arrow Keys</b> or the <b>Joystick</b> to tilt the floor.</p>
                    <p>Roll the ball into the <b>green zone</b>.</p>
                    <p>Don't fall off!</p>
                `;
            } else if (currentLang === 'zh') {
                instr.innerHTML = `
                    <h2>重力谜题房间</h2>
                    <p>使用<b>方向键</b>或屏幕<b>摇杆</b>来倾斜地板。</p>
                    <p>把球滚进<b>绿色区域</b>。</p>
                    <p>注意不要掉下去！</p>
                `;
            } else {
                instr.innerHTML = `
                    <h2>غرفة لغز الجاذبية</h2>
                    <p>استخدم <b>أسهم لوحة المفاتيح</b> أو <b>عصا التحكم</b> لإمالة الأرضية.</p>
                    <p>دحرج الكرة إلى <b>المنطقة الخضراء</b>.</p>
                    <p>إياك أن تسقط خارج الحافة!</p>
                `;
            }

            restartGame();
            saveGame(AUTO_SLOT);
        }

        function loadEnding() {
            currentMode = "ending";
            hideAllRooms();
            toggleJoystick(false);
            
            document.getElementById('puzzle-restart-btn').style.display = 'none';

            const instr = document.getElementById('instructions');
            const statusEl = document.getElementById('status-msg');
            const startText = document.getElementById('start-text');

            instr.style.display = 'none';
            startText.style.display = 'none';

            camera = perspCamera;
            camera.position.set(0, 12, 15);
            camera.lookAt(0, 0, 0);
            cameraBasePosition.copy(camera.position);

            statusEl.style.display = 'block';
            statusEl.className = 'win';
            if (currentLang === 'en') {
                statusEl.textContent = "You step through the portal and escape the maze!\nThanks for playing.";
                showStatus("The labyrinth dissolves behind you...", 3000);
            } else if (currentLang === 'zh') {
                statusEl.textContent = "你踏入传送门，成功逃出了迷宫！\n感谢游玩。";
                showStatus("在你身后，迷宫缓缓消散……", 3000);
            } else {
                statusEl.textContent = "تدخل عبر البوابة وتهرب من المتاهة!\nشكرًا على اللعب.";
                showStatus("المتاهة تختفي ببطء خلفك…", 3000);
            }

            saveGame(AUTO_SLOT);
        }

        function updateInventoryUI() {
            const invEl = document.getElementById('inventory-ui');
            if (!invEl) return;
            if (inventory.size === 0) {
                if (currentLang === 'en') {
                    invEl.textContent = 'Inventory: (empty)';
                } else if (currentLang === 'zh') {
                    invEl.textContent = '背包： (空)';
                } else {
                    invEl.textContent = 'المخزون: (فارغ)';
                }
            } else {
                const names = Array.from(inventory).map(id => getItemDisplayName(id));
                let prefix;
                if (currentLang === 'en') {
                    prefix = 'Inventory: ';
                } else if (currentLang === 'zh') {
                    prefix = '背包：';
                } else {
                    prefix = 'المخزون: ';
                }
                invEl.textContent = prefix + names.join(', ');
            }
            refreshItemVisibility();
        }

        function showStatus(text, timeout = 2000) {
            const msgEl = document.getElementById('message');
            if (!msgEl) return;
            msgEl.textContent = text;
            msgEl.style.display = 'block';
            if (timeout > 0) {
                clearTimeout(showStatus._timeoutId);
                showStatus._timeoutId = setTimeout(() => {
                    msgEl.style.display = 'none';
                }, timeout);
            }
        }

        // --- Language UI text (static parts) ---
        function refreshLanguageStaticUI() {
            const menuTitle = document.querySelector('#expanded-menu h2');
            const saveLabel = document.querySelector('#save-ui span');
            const themeLabel = document.querySelector('#theme-ui span');
            const langLabel = document.querySelector('#lang-ui span');
            const closeBtn = document.getElementById('close-menu-btn');
            const restartRunBtn = document.querySelector('#save-ui button[data-slot="restart"]');
            const startText = document.getElementById('start-text');

            applyDirForLang();

            if (menuTitle) {
                if (currentLang === 'en') {
                    menuTitle.textContent = 'PAUSE / MENU';
                } else if (currentLang === 'zh') {
                    menuTitle.textContent = '暂停 / 菜单';
                } else {
                    menuTitle.textContent = 'إيقاف مؤقت / قائمة';
                }
            }
            if (saveLabel) {
                if (currentLang === 'en') {
                    saveLabel.textContent = 'Saves:';
                } else if (currentLang === 'zh') {
                    saveLabel.textContent = '存档：';
                } else {
                    saveLabel.textContent = 'الحفظات:';
                }
            }
            if (themeLabel) {
                if (currentLang === 'en') {
                    themeLabel.textContent = 'Theme:';
                } else if (currentLang === 'zh') {
                    themeLabel.textContent = '主题：';
                } else {
                    themeLabel.textContent = 'السمة:';
                }
            }
            if (langLabel) {
                if (currentLang === 'en') {
                    langLabel.textContent = 'Language:';
                } else if (currentLang === 'zh') {
                    langLabel.textContent = '语言：';
                } else {
                    langLabel.textContent = 'اللغة:';
                }
            }
            if (closeBtn) {
                if (currentLang === 'en') {
                    closeBtn.textContent = 'Resume Game';
                } else if (currentLang === 'zh') {
                    closeBtn.textContent = '继续游戏';
                } else {
                    closeBtn.textContent = 'متابعة اللعبة';
                }
            }
            if (restartRunBtn) {
                if (currentLang === 'en') {
                    restartRunBtn.textContent = 'Restart Run';
                } else if (currentLang === 'zh') {
                    restartRunBtn.textContent = '重新开始一轮';
                } else {
                    restartRunBtn.textContent = 'إعادة الجولة';
                }
            }
            if (startText) {
                if (currentLang === 'en') {
                    startText.textContent = 'START GAME ↓';
                } else if (currentLang === 'zh') {
                    startText.textContent = '开始游戏 ↓';
                } else {
                    startText.textContent = 'ابدأ اللعبة ↓';
                }
            }

            // Localize Save/Load button labels
            const saveButtons = document.querySelectorAll('#save-ui button[data-slot][data-action]');
            saveButtons.forEach(btn => {
                const slot = btn.dataset.slot;
                const action = btn.dataset.action;
                if (slot === 'restart') return;
                const num = slot ? slot.replace('slot', '') : '';
                if (!num) return;

                if (currentLang === 'en') {
                    if (action === 'save') btn.textContent = 'Save ' + num;
                    if (action === 'load') btn.textContent = 'Load ' + num;
                } else if (currentLang === 'zh') {
                    if (action === 'save') btn.textContent = '存档 ' + num;
                    if (action === 'load') btn.textContent = '读档 ' + num;
                } else {
                    if (action === 'save') btn.textContent = 'حفظ ' + num;
                    if (action === 'load') btn.textContent = 'تحميل ' + num;
                }
            });

            // Localize theme buttons text
            const themeButtons = document.querySelectorAll('#theme-ui button[data-theme]');
            themeButtons.forEach(btn => {
                const mode = btn.dataset.theme;
                if (mode === 'system') {
                    if (currentLang === 'en') {
                        btn.textContent = 'System';
                    } else if (currentLang === 'zh') {
                        btn.textContent = '跟随系统';
                    } else {
                        btn.textContent = 'النظام';
                    }
                } else if (mode === 'light') {
                    if (currentLang === 'en') {
                        btn.textContent = 'Light';
                    } else if (currentLang === 'zh') {
                        btn.textContent = '浅色';
                    } else {
                        btn.textContent = 'فاتح';
                    }
                } else if (mode === 'dark') {
                    if (currentLang === 'en') {
                        btn.textContent = 'Dark';
                    } else if (currentLang === 'zh') {
                        btn.textContent = '深色';
                    } else {
                        btn.textContent = 'داكن';
                    }
                }
            });

            updateInventoryUI();
        }

        function refreshLanguageForCurrentMode() {
            if (currentMode === 'menu') {
                loadMenu();
            } else if (currentMode === 'maze') {
                showMazeRoom(currentRoomRow, currentRoomCol, true);
            } else if (currentMode === 'puzzle') {
                const instr = document.getElementById('instructions');
                if (currentLang === 'en') {
                    instr.innerHTML = `
                        <h2>Gravity Puzzle Room</h2>
                        <p>Use <b>Arrow Keys</b> or the <b>Joystick</b> to tilt the floor.</p>
                        <p>Roll the ball into the <b>green zone</b>.</p>
                        <p>Don't fall off!</p>
                    `;
                } else if (currentLang === 'zh') {
                    instr.innerHTML = `
                        <h2>重力谜题房间</h2>
                        <p>使用<b>方向键</b>或屏幕<b>摇杆</b>来倾斜地板。</p>
                        <p>把球滚进<b>绿色区域</b>。</p>
                        <p>注意不要掉下去！</p>
                    `;
                } else {
                    instr.innerHTML = `
                        <h2>غرفة لغز الجاذبية</h2>
                        <p>استخدم <b>أسهم لوحة المفاتيح</b> أو <b>عصا التحكم</b> لإمالة الأرضية.</p>
                        <p>دحرج الكرة إلى <b>المنطقة الخضراء</b>.</p>
                        <p>إياك أن تسقط خارج الحافة!</p>
                    `;
                }
            } else if (currentMode === 'ending') {
                loadEnding();
            }
        }

        // --- Input / interaction ---
        function onPointerDown(event) {
            const menu = document.getElementById('expanded-menu');
            if (menu.classList.contains('open')) return;
            
            if (event.target.closest('#joystick-zone')) return;
            if (event.target.closest('.header-btn')) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            let clickable = [];
            if (currentMode === "menu") {
                clickable = menuGroup.children;
            } else if (currentMode === "maze") {
                clickable = mazeRooms[currentRoomRow][currentRoomCol].children;
            } else if (currentMode === "puzzle") {
                clickable = puzzleGroup.children;
            } else {
                return;
            }

            const hits = raycaster.intersectObjects(clickable, true);
            if (hits.length === 0) return;

            const obj = hits[0].object;

            if (currentMode === "menu" && obj.userData.type === "startGame") {
                showMazeRoom(CENTER_ROW, CENTER_COL);
                return;
            }

            if (currentMode === "maze") {
                if (obj.userData.type === "item") {
                    const id = obj.userData.itemId;
                    if (!inventory.has(id)) {
                        inventory.add(id);
                        updateInventoryUI();
                        const name = getItemDisplayName(id);
                        let msg;
                        if (currentLang === 'en') {
                            msg = "Picked up " + name + "!";
                        } else if (currentLang === 'zh') {
                            msg = "拾取了 " + name + "！";
                        } else {
                            msg = "لقد حصلت على " + name + "!";
                        }
                        showStatus(msg);
                    }

                    if (inventory.has("ball") && inventory.has("plate") && !hasKey) {
                        returnRoomRow = currentRoomRow;
                        returnRoomCol = currentRoomCol;

                        startScreenShake(0.45, 0.8);
                        let msg;
                        if (currentLang === 'en') {
                            msg = "The floor trembles... you are dragged elsewhere!";
                        } else if (currentLang === 'zh') {
                            msg = "地面开始震动……你被突然拖向某个地方！";
                        } else {
                            msg = "الأرض تهتز… يتم سحبك إلى مكان آخر!";
                        }
                        showStatus(msg, 2000);
                        saveGame(AUTO_SLOT);
                        setTimeout(() => {
                            loadPuzzleScene();
                        }, 800);
                    } else {
                        saveGame(AUTO_SLOT);
                    }
                    return;
                }

                if (obj.userData.type === "door") {
                    const kind = obj.userData.kind || "mazeDoor";

                    if (kind === "mazeDoor") {
                        const nr = obj.userData.row;
                        const nc = obj.userData.col;
                        showMazeRoom(nr, nc);
                        return;
                    }

                    if (kind === "finalExit") {
                        if (!hasKey) {
                            let msg;
                            if (currentLang === 'en') {
                                msg = "The portal is sealed. A key-shaped slot glows faintly.";
                            } else if (currentLang === 'zh') {
                                msg = "传送门被封印了，上面有一个微微发光的钥匙孔。";
                            } else {
                                msg = "البوابة مغلقة. يوجد فتحة على شكل مفتاح تلمع بخفوت.";
                            }
                            showStatus(msg);
                        } else {
                            let msg;
                            if (currentLang === 'en') {
                                msg = "You raise the key. The portal roars to life...";
                            } else if (currentLang === 'zh') {
                                msg = "你举起钥匙，传送门瞬间被唤醒……";
                            } else {
                                msg = "ترفع المفتاح فتستجيب البوابة بصوت عال…";
                            }
                            showStatus(msg);
                            loadEnding();
                        }
                        return;
                    }
                }
            }
        }

        // --- Puzzle control & physics ---
        function restartGame() {
            if (!ballBody || !floorBody) return;
            gameActive = true;

            ballBody.position.set(-5, 5, -5);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);

            floorBody.quaternion.setFromEuler(0, 0, 0);

            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'none';
            statusEl.className = '';
        }

        function updatePhysics() {
            if (currentMode !== "puzzle") return;
            if (!ballBody || !floorBody) return;

            if (gameActive) {
                const maxTilt = 0.3;

                const currentEuler = new CANNON.Vec3();
                floorBody.quaternion.toEuler(currentEuler);

                let targetX = 0;
                let targetZ = 0;

                if (keys.ArrowUp) targetX = -maxTilt;
                if (keys.ArrowDown) targetX = maxTilt;
                if (keys.ArrowLeft) targetZ = maxTilt;
                if (keys.ArrowRight) targetZ = -maxTilt;

                currentEuler.x += (targetX - currentEuler.x) * 0.05;
                currentEuler.z += (targetZ - currentEuler.z) * 0.05;

                floorBody.quaternion.setFromEuler(currentEuler.x, 0, currentEuler.z);
            }

            world.step(timeStep);

            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);

            floorMesh.position.copy(floorBody.position);
            floorMesh.quaternion.copy(floorBody.quaternion);

            if (gameActive) {
                checkWinCondition();
            }
        }

        function checkWinCondition() {
            if (ballBody.position.y < -10) {
                endGame(false);
            }

            const dx = ballBody.position.x - TARGET_POS.x;
            const dz = ballBody.position.z - TARGET_POS.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < TARGET_RADIUS && ballBody.position.y > -1) {
                endGame(true);
            }
        }

        function endGame(isWin) {
            gameActive = false;
            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'block';

            if (isWin) {
                if (currentLang === 'en') {
                    statusEl.textContent = "SUCCESS!\nYou obtained a key.";
                } else if (currentLang === 'zh') {
                    statusEl.textContent = "成功！\n你获得了一把钥匙。";
                } else {
                    statusEl.textContent = "نجاح!\nلقد حصلت على مفتاح.";
                }
                statusEl.className = 'win';

                if (!hasKey) {
                    hasKey = true;
                    inventory.add("key");
                    updateInventoryUI();
                    let msg;
                    if (currentLang === 'en') {
                        msg = "A strange key appears in your hand.\nYou are pulled back into the maze.";
                    } else if (currentLang === 'zh') {
                        msg = "一把奇怪的钥匙突然出现在你手中。\n你被拉回了迷宫。";
                    } else {
                        msg = "مفتاح غريب يظهر في يدك.\nيتم سحبك مجددًا إلى المتاهة.";
                    }
                    showStatus(msg, 2500);
                }

                setTimeout(() => {
                    showMazeRoom(returnRoomRow, returnRoomCol);
                }, 1500);
            } else {
                if (currentLang === 'en') {
                    statusEl.textContent = "FAILURE";
                } else if (currentLang === 'zh') {
                    statusEl.textContent = "失败";
                } else {
                    statusEl.textContent = "فشل";
                }
                statusEl.className = 'lose';
                let msg;
                if (currentLang === 'en') {
                    msg = "Press the Restart button to retry.";
                } else if (currentLang === 'zh') {
                    msg = "点击“重新开始”按钮再试一次。";
                } else {
                    msg = "اضغط زر \"إعادة الجولة\" للمحاولة مرة أخرى.";
                }
                showStatus(msg);
            }
            saveGame(AUTO_SLOT);
        }

        // --- Misc ---
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const isPortrait = aspect < 1.0;

            let effectiveViewSize = viewSize;
            if (isPortrait) {
                effectiveViewSize = viewSize * 1.5;
            }

            orthoCamera.left   = -effectiveViewSize * aspect;
            orthoCamera.right  =  effectiveViewSize * aspect;
            orthoCamera.top    =  effectiveViewSize;
            orthoCamera.bottom = -effectiveViewSize;
            orthoCamera.updateProjectionMatrix();

            let perspDist = isPortrait ? 30 : 15;
            let perspHeight = 12;

            if (currentMode === 'puzzle') {
                perspDist = isPortrait ? 45 : 25;
                perspHeight = isPortrait ? 35 : 20;
            }

            perspCamera.aspect = aspect;
            if (currentMode === 'puzzle' || currentMode === 'menu') {
                perspCamera.position.set(0, perspHeight, perspDist);
                perspCamera.lookAt(0, (currentMode === 'menu' ? 10 : 0), 0);
            }
            perspCamera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateScreenShake();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
