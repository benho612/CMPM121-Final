<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>F2 Prototype: Gravity Escape</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #111;
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            pointer-events: none;
            z-index: 10;
        }
        #instructions {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 4px;
            max-width: 340px;
        }
        #inventory-ui {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 10;
        }
        #status-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            display: none;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
            z-index: 20;
            white-space: pre-line;
        }
        .win { color: #4ade80; }
        .lose { color: #f87171; }

        #start-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        #message {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 16px;
            display: none;
            z-index: 15;
        }
    </style>

    <!-- Import Maps for Three.js and Cannon-es -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="ui-layer">
        <div id="instructions"></div>
    </div>

    <div id="inventory-ui">Inventory: (empty)</div>
    <div id="status-msg"></div>
    <div id="message"></div>

    <div id="start-text">START GAME ↓</div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, renderer;
        let world;
        const timeStep = 1 / 60;

        // Cameras
        let perspCamera, orthoCamera, camera;
        const viewSize = 15; // orthographic zoom

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Modes: menu | maze | puzzle | ending
        let currentMode = "menu";

        // Maze rooms: 3x3
        const NUM_ROWS = 3;
        const NUM_COLS = 3;
        const CENTER_ROW = 1;
        const CENTER_COL = 1;
        const mazeRooms = []; // [row][col] = THREE.Group
        let currentRoomRow = CENTER_ROW;
        let currentRoomCol = CENTER_COL;

        // When entering puzzle, remember which room we came from
        let returnRoomRow = CENTER_ROW;
        let returnRoomCol = CENTER_COL;

        // Screen shake state
        let shakeTime = 0;
        let shakeDuration = 0;
        let shakeIntensity = 0;
        const cameraBasePosition = new THREE.Vector3();

        // Groups for non-maze scenes
        let menuGroup;
        let puzzleGroup;

        // Physics objects (puzzle)
        let ballMesh, ballBody;
        let floorMesh, floorBody;
        let targetMesh;

        // Game state / inventory
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const TARGET_POS = { x: 8, z: 8 };
        const TARGET_RADIUS = 1.5;

        const inventory = new Set();
        let hasKey = false;
        let gameActive = false;

        // Random placement
        let ballRoomCoord = null;
        let plateRoomCoord = null;
        let portalRoomCoord = null;

        init();
        animate();

        function init() {
            // THREE.js setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202025);
            scene.fog = new THREE.Fog(0x202025, 10, 60);

            const aspect = window.innerWidth / window.innerHeight;

            // Perspective camera (menu, puzzle, ending)
            perspCamera = new THREE.PerspectiveCamera(
                45,
                aspect,
                0.1,
                100
            );
            perspCamera.position.set(0, 20, 25);
            perspCamera.lookAt(0, 0, 0);

            // Orthographic camera (maze rooms)
            orthoCamera = new THREE.OrthographicCamera(
                -viewSize * aspect,
                viewSize * aspect,
                viewSize,
                -viewSize,
                0.1,
                100
            );
            orthoCamera.position.set(0, 25, 0);
            orthoCamera.lookAt(0, 0, 0);
            orthoCamera.up.set(0, 0, -1);

            camera = perspCamera;
            cameraBasePosition.copy(camera.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            // CANNON World
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0)
            });

            const physicsMaterial = new CANNON.Material('physics');
            const physicsContactMaterial = new CANNON.ContactMaterial(
                physicsMaterial,
                physicsMaterial,
                { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(physicsContactMaterial);

            // Groups
            menuGroup = new THREE.Group();
            scene.add(menuGroup);

            // Maze rooms groups
            for (let r = 0; r < NUM_ROWS; r++) {
                mazeRooms[r] = [];
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = new THREE.Group();
                    mazeRooms[r][c] = g;
                    scene.add(g);
                }
            }

            puzzleGroup = new THREE.Group();
            scene.add(puzzleGroup);

            // --- MENU ---
            {
                const startButtonGeo = new THREE.PlaneGeometry(6, 2);
                const startButtonMat = new THREE.MeshBasicMaterial({
                    color: 0x44ff88,
                    side: THREE.DoubleSide
                });
                const startButton = new THREE.Mesh(startButtonGeo, startButtonMat);
                startButton.position.set(0, 10, 0);
                startButton.rotation.x = -Math.PI / 4;
                startButton.userData.type = "startGame";
                menuGroup.add(startButton);
            }

            // Helper: build basic room
            function buildBasicRoom(group) {
                const floorGeo = new THREE.BoxGeometry(12, 1, 12);
                const floorMat = new THREE.MeshStandardMaterial({ color: 0x444466 });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.receiveShadow = true;
                floor.position.y = 0;
                group.add(floor);

                const wallGeoZ = new THREE.BoxGeometry(12, 1.2, 0.5);
                const wallGeoX = new THREE.BoxGeometry(0.5, 1.2, 12);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x222233 });

                const backWall = new THREE.Mesh(wallGeoZ, wallMat);
                backWall.position.set(0, 0.6, -6);
                group.add(backWall);

                const frontWall = new THREE.Mesh(wallGeoZ, wallMat);
                frontWall.position.set(0, 0.6, 6);
                group.add(frontWall);

                const leftWall = new THREE.Mesh(wallGeoX, wallMat);
                leftWall.position.set(-6, 0.6, 0);
                group.add(leftWall);

                const rightWall = new THREE.Mesh(wallGeoX, wallMat);
                rightWall.position.set(6, 0.6, 0);
                group.add(rightWall);
            }

            // Build all maze rooms (geometry only)
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    buildBasicRoom(mazeRooms[r][c]);
                }
            }

            // Add doors between adjacent rooms
            const doorGeo = new THREE.BoxGeometry(2, 3, 0.5);
            const doorMatMaze = new THREE.MeshStandardMaterial({ color: 0x64748b });

            function addMazeDoor(group, direction, targetRow, targetCol) {
                const door = new THREE.Mesh(doorGeo, doorMatMaze);
                door.userData.type = "door";
                door.userData.kind = "mazeDoor";
                door.userData.row = targetRow;
                door.userData.col = targetCol;

                if (direction === "north") {
                    door.position.set(0, 1.5, -5.75);
                } else if (direction === "south") {
                    door.position.set(0, 1.5, 5.75);
                } else if (direction === "west") {
                    door.rotation.y = Math.PI / 2;
                    door.position.set(-5.75, 1.5, 0);
                } else if (direction === "east") {
                    door.rotation.y = Math.PI / 2;
                    door.position.set(5.75, 1.5, 0);
                }

                group.add(door);
            }

            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = mazeRooms[r][c];
                    if (r > 0) addMazeDoor(g, "north", r - 1, c);
                    if (r < NUM_ROWS - 1) addMazeDoor(g, "south", r + 1, c);
                    if (c > 0) addMazeDoor(g, "west", r, c - 1);
                    if (c < NUM_COLS - 1) addMazeDoor(g, "east", r, c + 1);
                }
            }

            // --- Random placement of ball / plate / portal ---
            const coords = [];
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    if (r === CENTER_ROW && c === CENTER_COL) continue;
                    coords.push({ r, c });
                }
            }
            shuffleArray(coords);
            ballRoomCoord = coords[0];
            plateRoomCoord = coords[1];
            portalRoomCoord = coords[2];

            // Place ball
            {
                const { r, c } = ballRoomCoord;
                const group = mazeRooms[r][c];
                const ballGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4b4b });
                const ball = new THREE.Mesh(ballGeo, ballMat);
                ball.position.set(0, 1, 0);
                ball.castShadow = true;
                ball.userData.type = "item";
                ball.userData.itemId = "ball";
                group.add(ball);
            }

            // Place plate
            {
                const { r, c } = plateRoomCoord;
                const group = mazeRooms[r][c];
                const plateGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.2, 32);
                const plateMat = new THREE.MeshStandardMaterial({ color: 0x4ade80 });
                const plate = new THREE.Mesh(plateGeo, plateMat);
                plate.position.set(0, 1, 0);
                plate.castShadow = true;
                plate.userData.type = "item";
                plate.userData.itemId = "plate";
                group.add(plate);
            }

            // Place locked portal door in portalRoom on an outer wall
            {
                const { r, c } = portalRoomCoord;
                const group = mazeRooms[r][c];
                const portalGeo = new THREE.BoxGeometry(2, 3, 0.5);
                const portalMat = new THREE.MeshStandardMaterial({ color: 0x8b5cf6 });

                const portalDoor = new THREE.Mesh(portalGeo, portalMat);
                portalDoor.userData.type = "door";
                portalDoor.userData.kind = "finalExit";
                portalDoor.userData.target = "ending";

                // choose an outer wall with no neighbour
                if (r === 0) {
                    portalDoor.position.set(0, 1.5, -5.75);
                } else if (r === NUM_ROWS - 1) {
                    portalDoor.position.set(0, 1.5, 5.75);
                } else if (c === 0) {
                    portalDoor.rotation.y = Math.PI / 2;
                    portalDoor.position.set(-5.75, 1.5, 0);
                } else {
                    portalDoor.rotation.y = Math.PI / 2;
                    portalDoor.position.set(5.75, 1.5, 0);
                }

                group.add(portalDoor);
            }

            // --- PUZZLE ROOM (same physics puzzle) ---
            {
                const floorGeoB = new THREE.BoxGeometry(20, 1, 20);
                const floorMatB = new THREE.MeshStandardMaterial({ color: 0x666644 });
                floorMesh = new THREE.Mesh(floorGeoB, floorMatB);
                floorMesh.receiveShadow = true;
                puzzleGroup.add(floorMesh);

                const floorShape = new CANNON.Box(new CANNON.Vec3(10, 0.5, 10));
                floorBody = new CANNON.Body({
                    mass: 0,
                    type: CANNON.Body.KINEMATIC,
                    material: physicsMaterial
                });
                floorBody.addShape(floorShape);
                world.addBody(floorBody);

                const ballRadius = 0.8;
                const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 });
                ballMesh = new THREE.Mesh(ballGeo, ballMat);
                ballMesh.castShadow = true;
                puzzleGroup.add(ballMesh);

                const ballShape = new CANNON.Sphere(ballRadius);
                ballBody = new CANNON.Body({
                    mass: 5,
                    shape: ballShape,
                    material: physicsMaterial
                });
                ballBody.position.set(-5, 5, -5);
                ballBody.linearDamping = 0.1;
                world.addBody(ballBody);

                const targetGeo = new THREE.CylinderGeometry(
                    TARGET_RADIUS,
                    TARGET_RADIUS,
                    0.1,
                    32
                );
                const targetMat = new THREE.MeshBasicMaterial({
                    color: 0x4ade80,
                    opacity: 0.5,
                    transparent: true
                });
                targetMesh = new THREE.Mesh(targetGeo, targetMat);
                targetMesh.position.set(TARGET_POS.x, 0.6, TARGET_POS.z);
                floorMesh.add(targetMesh);
            }

            // Events
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
                if (e.key.toLowerCase() === 'r') restartGame();
            });
            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
            });

            updateInventoryUI();
            loadMenu();
        }

        // --- Utility: shuffle array ---
        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        // --- Screen shake helpers ---
        function startScreenShake(duration = 0.4, intensity = 0.6) {
            shakeDuration = duration;
            shakeTime = duration;
            shakeIntensity = intensity;
            cameraBasePosition.copy(camera.position);
        }

        function updateScreenShake() {
            if (shakeTime <= 0) return;

            const progress = 1 - shakeTime / shakeDuration;
            const damper = 1 - progress;

            const offsetX = (Math.random() - 0.5) * 2 * shakeIntensity * damper;
            const offsetY = (Math.random() - 0.5) * 2 * shakeIntensity * damper;

            camera.position.set(
                cameraBasePosition.x + offsetX,
                cameraBasePosition.y + offsetY,
                cameraBasePosition.z
            );

            shakeTime -= timeStep;
            if (shakeTime <= 0) {
                camera.position.copy(cameraBasePosition);
            }
        }

        // --- Scene helpers ---
        function hideAllRooms() {
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    mazeRooms[r][c].visible = false;
                }
            }
            menuGroup.visible = false;
            puzzleGroup.visible = false;
        }

        function loadMenu() {
            currentMode = "menu";
            hideAllRooms();
            menuGroup.visible = true;

            const instr = document.getElementById('instructions');
            const startText = document.getElementById('start-text');
            const statusEl = document.getElementById('status-msg');

            statusEl.style.display = 'none';
            statusEl.className = '';

            camera = perspCamera;
            camera.position.set(0, 12, 15);
            camera.lookAt(0, 10, 0);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'none';
            startText.style.display = 'block';
        }

        function showMazeRoom(row, col) {
            currentMode = "maze";
            currentRoomRow = row;
            currentRoomCol = col;

            hideAllRooms();
            mazeRooms[row][col].visible = true;

            const instr = document.getElementById('instructions');
            const startText = document.getElementById('start-text');
            const statusEl = document.getElementById('status-msg');

            startText.style.display = 'none';
            statusEl.style.display = 'none';
            statusEl.className = '';

            camera = orthoCamera;
            camera.position.set(0, 25, 0);
            camera.lookAt(0, 0, 0);
            camera.up.set(0, 0, -1);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'block';

            const isCenter = (row === CENTER_ROW && col === CENTER_COL);

            if (isCenter) {
                instr.innerHTML = `
                    <h2>Central Room</h2>
                    <p>You are in the <b>center</b> of a 3×3 maze.</p>
                    <p>Somewhere in the maze lie a <b>ball</b>, a <b>plate</b>, and a <b>locked portal</b>.</p>
                    <p>Explore with doors. Once you collect both items, you'll be dragged into a gravity puzzle.</p>
                    <p>Beat the puzzle to get a <b>key</b>, then find the portal room and escape.</p>
                `;
            } else {
                instr.innerHTML = `
                    <h2>Maze Room</h2>
                    <p>This is one of the nine rooms in the maze.</p>
                    <p>Click objects to interact, and doors to move to adjacent rooms.</p>
                    <p>Remember: you need a <b>ball</b>, a <b>plate</b>, then clear the puzzle to find the final portal.</p>
                `;
            }
        }

        function loadPuzzleScene() {
            currentMode = "puzzle";
            hideAllRooms();
            puzzleGroup.visible = true;

            const instr = document.getElementById('instructions');
            const startText = document.getElementById('start-text');
            const statusEl = document.getElementById('status-msg');

            startText.style.display = 'none';
            statusEl.style.display = 'none';
            statusEl.className = '';

            camera = perspCamera;
            camera.position.set(0, 20, 25);
            camera.lookAt(0, 0, 0);
            cameraBasePosition.copy(camera.position);

            instr.style.display = 'block';
            instr.innerHTML = `
                <h2>Gravity Puzzle Room</h2>
                <p>Use <b>Arrow Keys</b> to tilt the floor and roll the ball into the <b>green zone</b>.</p>
                <p>Don't fall off! Press <b>R</b> to restart the puzzle.</p>
                <p>Win to receive a <b>key</b> and return to the maze.</p>
            `;
            restartGame();
        }

        function loadEnding() {
            currentMode = "ending";
            hideAllRooms();
            const instr = document.getElementById('instructions');
            const statusEl = document.getElementById('status-msg');
            const startText = document.getElementById('start-text');

            instr.style.display = 'none';
            startText.style.display = 'none';

            camera = perspCamera;
            camera.position.set(0, 12, 15);
            camera.lookAt(0, 0, 0);
            cameraBasePosition.copy(camera.position);

            statusEl.style.display = 'block';
            statusEl.className = 'win';
            statusEl.textContent = "You step through the portal and escape the maze!\nThanks for playing.";
            showStatus("The labyrinth dissolves behind you...", 3000);
        }

        function updateInventoryUI() {
            const invEl = document.getElementById('inventory-ui');
            if (!invEl) return;
            if (inventory.size === 0) {
                invEl.textContent = 'Inventory: (empty)';
            } else {
                invEl.textContent = 'Inventory: ' + Array.from(inventory).join(', ');
            }
        }

        function showStatus(text, timeout = 2000) {
            const msgEl = document.getElementById('message');
            if (!msgEl) return;
            msgEl.textContent = text;
            msgEl.style.display = 'block';
            if (timeout > 0) {
                clearTimeout(showStatus._timeoutId);
                showStatus._timeoutId = setTimeout(() => {
                    msgEl.style.display = 'none';
                }, timeout);
            }
        }

        // --- Input / interaction ---
        function onPointerDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            let clickable = [];
            if (currentMode === "menu") {
                clickable = menuGroup.children;
            } else if (currentMode === "maze") {
                clickable = mazeRooms[currentRoomRow][currentRoomCol].children;
            } else if (currentMode === "puzzle") {
                clickable = puzzleGroup.children;
            } else {
                return;
            }

            const hits = raycaster.intersectObjects(clickable, true);
            if (hits.length === 0) return;

            const obj = hits[0].object;

            // MENU
            if (currentMode === "menu" && obj.userData.type === "startGame") {
                showMazeRoom(CENTER_ROW, CENTER_COL);
                return;
            }

            // MAZE
            if (currentMode === "maze") {
                if (obj.userData.type === "item") {
                    const id = obj.userData.itemId;
                    if (!inventory.has(id)) {
                        inventory.add(id);
                        updateInventoryUI();
                        obj.visible = false;
                        showStatus("Picked up " + id + "!");
                    }

                    // If ball + plate collected and no key yet -> auto enter puzzle
                    if (inventory.has("ball") && inventory.has("plate") && !hasKey) {
                        // Remember current room to return here after puzzle
                        returnRoomRow = currentRoomRow;
                        returnRoomCol = currentRoomCol;

                        // Trigger screen shake when the last item is collected
                        startScreenShake(0.45, 0.8);

                        showStatus("The floor trembles... you are dragged elsewhere!", 2000);
                        setTimeout(() => {
                            loadPuzzleScene();
                        }, 800);
                    }
                    return;
                }

                if (obj.userData.type === "door") {
                    const kind = obj.userData.kind || "mazeDoor";

                    if (kind === "mazeDoor") {
                        const nr = obj.userData.row;
                        const nc = obj.userData.col;
                        showMazeRoom(nr, nc);
                        return;
                    }

                    if (kind === "finalExit") {
                        if (!hasKey) {
                            showStatus("The portal is sealed. A key-shaped slot glows faintly.");
                        } else {
                            showStatus("You raise the key. The portal roars to life...");
                            loadEnding();
                        }
                        return;
                    }
                }
            }
        }

        // --- Puzzle control & physics ---
        function restartGame() {
            if (!ballBody || !floorBody) return;
            gameActive = true;

            ballBody.position.set(-5, 5, -5);
            ballBody.velocity.set(0, 0, 0);
            ballBody.angularVelocity.set(0, 0, 0);

            floorBody.quaternion.setFromEuler(0, 0, 0);

            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'none';
            statusEl.className = '';
        }

        function updatePhysics() {
            if (currentMode !== "puzzle") return;
            if (!ballBody || !floorBody) return;

            if (gameActive) {
                const maxTilt = 0.3;

                const currentEuler = new CANNON.Vec3();
                floorBody.quaternion.toEuler(currentEuler);

                let targetX = 0;
                let targetZ = 0;

                if (keys.ArrowUp) targetX = -maxTilt;
                if (keys.ArrowDown) targetX = maxTilt;
                if (keys.ArrowLeft) targetZ = maxTilt;
                if (keys.ArrowRight) targetZ = -maxTilt;

                currentEuler.x += (targetX - currentEuler.x) * 0.05;
                currentEuler.z += (targetZ - currentEuler.z) * 0.05;

                floorBody.quaternion.setFromEuler(currentEuler.x, 0, currentEuler.z);
            }

            world.step(timeStep);

            ballMesh.position.copy(ballBody.position);
            ballMesh.quaternion.copy(ballBody.quaternion);

            floorMesh.position.copy(floorBody.position);
            floorMesh.quaternion.copy(floorBody.quaternion);

            if (gameActive) {
                checkWinCondition();
            }
        }

        function checkWinCondition() {
            if (ballBody.position.y < -10) {
                endGame(false);
            }

            const dx = ballBody.position.x - TARGET_POS.x;
            const dz = ballBody.position.z - TARGET_POS.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < TARGET_RADIUS && ballBody.position.y > -1) {
                endGame(true);
            }
        }

        function endGame(isWin) {
            gameActive = false;
            const statusEl = document.getElementById('status-msg');
            statusEl.style.display = 'block';

            if (isWin) {
                statusEl.textContent = "SUCCESS!\nYou obtained a key.";
                statusEl.className = 'win';

                if (!hasKey) {
                    hasKey = true;
                    inventory.add("key");
                    updateInventoryUI();
                    showStatus("A strange key appears in your hand.\nYou are pulled back into the maze.", 2500);
                }

                setTimeout(() => {
                    // Return to the room where the player collected the second item
                    showMazeRoom(returnRoomRow, returnRoomCol);
                }, 1500);
            } else {
                statusEl.textContent = "FAILURE";
                statusEl.className = 'lose';
                showStatus("You can press R to retry the puzzle.");
            }
        }

        // --- Misc ---
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;

            orthoCamera.left   = -viewSize * aspect;
            orthoCamera.right  =  viewSize * aspect;
            orthoCamera.top    =  viewSize;
            orthoCamera.bottom = -viewSize;
            orthoCamera.updateProjectionMatrix();

            perspCamera.aspect = aspect;
            perspCamera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateScreenShake();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
