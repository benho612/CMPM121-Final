<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>F2 Prototype: Gravity Escape Mobile</title>
    <style>
        :root {
            color-scheme: light dark;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #111;
            color: #fff;
            touch-action: none; /* Prevent scroll on mobile */
        }

        /* --- UI Overlay Wrapper --- */
        #gear-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 24px;
            user-select: none;
        }

        #expanded-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 90;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            backdrop-filter: blur(5px);
        }

        #expanded-menu.open {
            display: flex;
        }

        /* Repurposed existing IDs to fit in menu */
        #inventory-ui, #save-ui, #theme-ui {
            position: relative;
            top: auto;
            left: auto;
            right: auto;
            bottom: auto;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            width: 80%;
            max-width: 300px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: inherit;
            pointer-events: none;
            z-index: 10;
            width: auto;
        }

        #instructions {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border-radius: 4px;
            max-width: 340px;
        }
        
        #status-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            font-weight: bold;
            display: none;
            text-shadow: 2px 2px 0 #000;
            text-align: center;
            z-index: 20;
            white-space: pre-line;
            pointer-events: none;
            width: 90%;
        }
        .win { color: #4ade80; }
        .lose { color: #f87171; }

        #start-text {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        #message {
            position: absolute;
            bottom: 160px; /* Moved up to clear joystick */
            left: 50%;
            transform: translateX(-50%);
            color: inherit;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 16px;
            display: none;
            z-index: 15;
            pointer-events: none;
            width: max-content;
            max-width: 90%;
            text-align: center;
        }

        /* UI Element Styling fixes for Menu Mode */
        #save-ui span, #theme-ui span {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        #save-ui button, #theme-ui button {
            padding: 8px;
            margin: 2px;
            font-size: 14px;
            cursor: pointer;
        }
        
        #theme-ui {
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* --- Joystick Controls --- */
        #joystick-zone {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 140px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 50;
            display: none; /* Shown only in puzzle + mobile */
            touch-action: none;
        }
        
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* --- Mobile / Phone Specific Styles --- */
        @media (max-width: 768px) {
            #ui-layer {
                /* Move UI from top-left to top-center and make smaller */
                top: 70px; /* Below the gear icon */
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                display: flex;
                justify-content: center;
            }

            #instructions {
                font-size: 12px; /* Smaller text */
                padding: 8px;
                max-width: 100%;
                text-align: center;
                background: rgba(0, 0, 0, 0.4); /* Less obtrusive opacity */
            }

            #instructions h2 {
                font-size: 14px;
                margin: 0 0 5px 0;
            }
            
            #message {
                bottom: 180px; /* Ensure it clears joystick */
                font-size: 14px;
            }
            
            #status-msg {
                font-size: 28px; /* Smaller win/lose text */
            }
        }

        @media (prefers-color-scheme: light) {
            body {
                background-color: #dbeafe;
                color: #111827;
            }

            #instructions {
                background: rgba(255, 255, 255, 0.9);
                color: #111827;
            }
            
            @media (max-width: 768px) {
                #instructions {
                    background: rgba(255, 255, 255, 0.7);
                }
            }

            #gear-btn {
                background: rgba(255, 255, 255, 0.8);
                border-color: #111827;
                color: #111827;
            }
            
            #expanded-menu {
                background: rgba(255, 255, 255, 0.95);
                color: #111827;
            }

            #inventory-ui, #save-ui, #theme-ui {
                background: rgba(0, 0, 0, 0.05);
                color: #111827;
            }

            #message {
                background: rgba(15, 23, 42, 0.9);
                color: #e5e7eb;
            }
            
            #joystick-zone {
                border-color: rgba(0,0,0,0.3);
                background: rgba(0,0,0,0.05);
            }
            #joystick-knob {
                background: rgba(0,0,0,0.5);
            }

            #start-text {
                color: #111827;
                text-shadow: 2px 2px 4px #ffffff88;
            }
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>
</head>
<body>
    <div id="gear-btn">⚙</div>

    <div id="expanded-menu">
        <h2>PAUSE / MENU</h2>
        <div id="inventory-ui">Inventory: (empty)</div>
        
        <div id="save-ui">
            <span>Saves:</span>
            <div>
                <button data-slot="slot1" data-action="save">Save 1</button>
                <button data-slot="slot1" data-action="load">Load 1</button>
            </div>
            <div>
                <button data-slot="slot2" data-action="save">Save 2</button>
                <button data-slot="slot2" data-action="load">Load 2</button>
            </div>
            <div>
                <button data-slot="slot3" data-action="save">Save 3</button>
                <button data-slot="slot3" data-action="load">Load 3</button>
            </div>
            <div style="margin-top:10px;">
                <button data-slot="restart" data-action="restart" style="background:#f87171; color:white; border:none;">Restart Run</button>
            </div>
        </div>

        <div id="theme-ui">
            <span style="width:100%">Theme:</span>
            <button data-theme="system" class="active">System</button>
            <button data-theme="light">Light</button>
            <button data-theme="dark">Dark</button>
        </div>
        
        <button id="close-menu-btn" style="padding:10px 20px; font-size:16px; cursor:pointer;">Resume Game</button>
    </div>

    <div id="ui-layer">
        <div id="instructions"></div>
    </div>

    <div id="status-msg"></div>
    <div id="message"></div>
    <div id="start-text">START GAME ↓</div>
    
    <div id="joystick-zone">
        <div id="joystick-knob"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        // --- Global Variables ---
        let scene, renderer;
        let world;
        const timeStep = 1 / 60;

        // Mobile Detection
        const isMobileDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        // Cameras
        let perspCamera, orthoCamera, camera;
        let viewSize = 15; // Base view size

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Modes: menu | maze | puzzle | ending
        let currentMode = "menu";

        // Maze rooms: 3x3
        const NUM_ROWS = 3;
        const NUM_COLS = 3;
        const CENTER_ROW = 1;
        const CENTER_COL = 1;
        const mazeRooms = [];
        let currentRoomRow = CENTER_ROW;
        let currentRoomCol = CENTER_COL;

        // When entering puzzle, remember which room we came from
        let returnRoomRow = CENTER_ROW;
        let returnRoomCol = CENTER_COL;

        // Screen shake state
        let shakeTime = 0;
        let shakeDuration = 0;
        let shakeIntensity = 0;
        const cameraBasePosition = new THREE.Vector3();

        // Lighting and theme
        let ambientLight;
        let dirLight;
        let themeMode = "system"; // system | light | dark
        let systemPrefersDark = false;

        // Materials that respond to theme
        const mazeFloorMats = [];
        const mazeWallMats = [];
        let puzzleFloorMat = null;

        // Groups for non-maze scenes
        let menuGroup;
        let puzzleGroup;

        // Physics objects (puzzle)
        let ballMesh, ballBody;
        let floorMesh, floorBody;
        let targetMesh;

        // Game state / inventory
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        const TARGET_POS = { x: 8, z: 8 };
        const TARGET_RADIUS = 1.5;

        const inventory = new Set();
        let hasKey = false;
        let gameActive = false;

        // Random placement
        let ballRoomCoord = null;
        let plateRoomCoord = null;
        let portalRoomCoord = null;

        // --- Save system globals ---
        const SAVE_PREFIX = "gravityEscape_";
        const AUTO_SLOT = "autosave";
        let pendingLoadData = null;

        try {
            const raw = localStorage.getItem(SAVE_PREFIX + AUTO_SLOT);
            if (raw) {
                pendingLoadData = JSON.parse(raw);
                if (pendingLoadData && typeof pendingLoadData === "object") {
                    currentMode = pendingLoadData.currentMode || "maze";
                    currentRoomRow = pendingLoadData.currentRoomRow ?? CENTER_ROW;
                    currentRoomCol = pendingLoadData.currentRoomCol ?? CENTER_COL;
                    returnRoomRow = pendingLoadData.returnRoomRow ?? CENTER_ROW;
                    returnRoomCol = pendingLoadData.returnRoomCol ?? CENTER_COL;
                    hasKey = !!pendingLoadData.hasKey;

                    if (Array.isArray(pendingLoadData.inventory)) {
                        pendingLoadData.inventory.forEach(id => inventory.add(id));
                    }

                    ballRoomCoord = pendingLoadData.ballRoomCoord || null;
                    plateRoomCoord = pendingLoadData.plateRoomCoord || null;
                    portalRoomCoord = pendingLoadData.portalRoomCoord || null;

                    if (pendingLoadData.themeMode) {
                        themeMode = pendingLoadData.themeMode;
                    }
                }
            }
        } catch (e) {
            console.warn("Failed to parse autosave:", e);
            pendingLoadData = null;
        }

        init();
        animate();

        function init() {
            // THREE.js setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x202025);
            scene.fog = new THREE.Fog(0x202025, 10, 60);

            const aspect = window.innerWidth / window.innerHeight;
            const isPortrait = aspect < 1.0;

            // Orthographic Camera (Maze): Adjusted for zoom scale
            let effectiveViewSize = viewSize;
            if (isPortrait) {
                effectiveViewSize = viewSize * 1.5;
            }

            // Perspective Camera (Puzzle): Adjusted for zoom scale
            // If portrait (phone), move Z back significantly to avoid "zoomed in" feel
            const puzzleCamDist = isPortrait ? 45 : 25;
            const puzzleCamHeight = isPortrait ? 35 : 20;

            perspCamera = new THREE.PerspectiveCamera(
                45,
                aspect,
                0.1,
                200
            );
            perspCamera.position.set(0, puzzleCamHeight, puzzleCamDist);
            perspCamera.lookAt(0, 0, 0);

            // Orthographic camera
            orthoCamera = new THREE.OrthographicCamera(
                -effectiveViewSize * aspect,
                effectiveViewSize * aspect,
                effectiveViewSize,
                -effectiveViewSize,
                0.1,
                100
            );
            orthoCamera.position.set(0, 25, 0);
            orthoCamera.lookAt(0, 0, 0);
            orthoCamera.up.set(0, 0, -1);

            camera = perspCamera;
            cameraBasePosition.copy(camera.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            // CANNON World
            world = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0)
            });

            const physicsMaterial = new CANNON.Material('physics');
            const physicsContactMaterial = new CANNON.ContactMaterial(
                physicsMaterial,
                physicsMaterial,
                { friction: 0.5, restitution: 0.3 }
            );
            world.addContactMaterial(physicsContactMaterial);

            // Groups
            menuGroup = new THREE.Group();
            scene.add(menuGroup);

            // Maze rooms groups
            for (let r = 0; r < NUM_ROWS; r++) {
                mazeRooms[r] = [];
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = new THREE.Group();
                    mazeRooms[r][c] = g;
                    scene.add(g);
                }
            }

            puzzleGroup = new THREE.Group();
            scene.add(puzzleGroup);

            // --- MENU ---
            {
                const startButtonGeo = new THREE.PlaneGeometry(6, 2);
                const startButtonMat = new THREE.MeshBasicMaterial({
                    color: 0x44ff88,
                    side: THREE.DoubleSide
                });
                const startButton = new THREE.Mesh(startButtonGeo, startButtonMat);
                startButton.position.set(0, 10, 0);
                startButton.rotation.x = -Math.PI / 4;
                startButton.userData.type = "startGame";
                menuGroup.add(startButton);
            }

            // Helper: build basic room
            function buildBasicRoom(group) {
                const floorGeo = new THREE.BoxGeometry(12, 1, 12);
                const floorMat = new THREE.MeshStandardMaterial({ color: 0x444466 });
                mazeFloorMats.push(floorMat);
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.receiveShadow = true;
                floor.position.y = 0;
                group.add(floor);

                const wallGeoZ = new THREE.BoxGeometry(12, 1.2, 0.5);
                const wallGeoX = new THREE.BoxGeometry(0.5, 1.2, 12);
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x222233 });
                mazeWallMats.push(wallMat);

                const backWall = new THREE.Mesh(wallGeoZ, wallMat);
                backWall.position.set(0, 0.6, -6);
                group.add(backWall);

                const frontWall = new THREE.Mesh(wallGeoZ, wallMat);
                frontWall.position.set(0, 0.6, 6);
                group.add(frontWall);

                const leftWall = new THREE.Mesh(wallGeoX, wallMat);
                leftWall.position.set(-6, 0.6, 0);
                group.add(leftWall);

                const rightWall = new THREE.Mesh(wallGeoX, wallMat);
                rightWall.position.set(6, 0.6, 0);
                group.add(rightWall);
            }

            // Build all maze rooms (geometry only)
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    buildBasicRoom(mazeRooms[r][c]);
                }
            }

            // Add doors between adjacent rooms
            const doorGeo = new THREE.BoxGeometry(2, 3, 0.5);
            const doorMatMaze = new THREE.MeshStandardMaterial({ color: 0x64748b });

            function addMazeDoor(group, direction, targetRow, targetCol) {
                const door = new THREE.Mesh(doorGeo, doorMatMaze);
                door.userData.type = "door";
                door.userData.kind = "mazeDoor";
                door.userData.row = targetRow;
                door.userData.col = targetCol;

                if (direction === "north") {
                    door.position.set(0, 1.5, -5.75);
                } else if (direction === "south") {
                    door.position.set(0, 1.5, 5.75);
                } else if (direction === "west") {
                    door.rotation.y = Math.PI / 2;
                    door.position.set(-5.75, 1.5, 0);
                } else if (direction === "east") {
                    door.rotation.y = Math.PI / 2;
                    door.position.set(5.75, 1.5, 0);
                }

                group.add(door);
            }

            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    const g = mazeRooms[r][c];
                    if (r > 0) addMazeDoor(g, "north", r - 1, c);
                    if (r < NUM_ROWS - 1) addMazeDoor(g, "south", r + 1, c);
                    if (c > 0) addMazeDoor(g, "west", r, c - 1);
                    if (c < NUM_COLS - 1) addMazeDoor(g, "east", r, c + 1);
                }
            }

            // --- Random placement of ball / plate / portal ---
            if (!ballRoomCoord || !plateRoomCoord || !portalRoomCoord) {
                const coords = [];
                for (let r = 0; r < NUM_ROWS; r++) {
                    for (let c = 0; c < NUM_COLS; c++) {
                        if (r === CENTER_ROW && c === CENTER_COL) continue;
                        coords.push({ r, c });
                    }
                }
                shuffleArray(coords);
                if (!ballRoomCoord) ballRoomCoord = coords[0];
                if (!plateRoomCoord) plateRoomCoord = coords[1];
                if (!portalRoomCoord) portalRoomCoord = coords[2];
            }

            // Place ball
            {
                const { r, c } = ballRoomCoord;
                const group = mazeRooms[r][c];
                const ballGeo = new THREE.SphereGeometry(0.6, 16, 16);
                const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4b4b });
                const ball = new THREE.Mesh(ballGeo, ballMat);
                ball.position.set(0, 1, 0);
                ball.castShadow = true;
                ball.userData.type = "item";
                ball.userData.itemId = "ball";
                group.add(ball);
            }

            // Place plate
            {
                const { r, c } = plateRoomCoord;
                const group = mazeRooms[r][c];
                const plateGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.2, 32);
                const plateMat = new THREE.MeshStandardMaterial({ color: 0x4ade80 });
                const plate = new THREE.Mesh(plateGeo, plateMat);
                plate.position.set(0, 1, 0);
                plate.castShadow = true;
                plate.userData.type = "item";
                plate.userData.itemId = "plate";
                group.add(plate);
            }

            // Place locked portal door in portalRoom on an outer wall
            {
                const { r, c } = portalRoomCoord;
                const group = mazeRooms[r][c];
                const portalGeo = new THREE.BoxGeometry(2, 3, 0.5);
                const portalMat = new THREE.MeshStandardMaterial({ color: 0x8b5cf6 });

            const portalDoor = new THREE.Mesh(portalGeo, portalMat);
            portalDoor.userData.type = "door";
            portalDoor.userData.kind = "finalExit";
            portalDoor.userData.target = "ending";

            if (r === 0) {
                portalDoor.position.set(0, 1.5, -5.75);
            } else if (r === NUM_ROWS - 1) {
                portalDoor.position.set(0, 1.5, 5.75);
            } else if (c === 0) {
                portalDoor.rotation.y = Math.PI / 2;
                portalDoor.position.set(-5.75, 1.5, 0);
            } else {
                portalDoor.rotation.y = Math.PI / 2;
                portalDoor.position.set(5.75, 1.5, 0);
            }

            group.add(portalDoor);
        }

        // --- PUZZLE ROOM (physics puzzle) ---
        {
            const floorGeoB = new THREE.BoxGeometry(20, 1, 20);
            const floorMatB = new THREE.MeshStandardMaterial({ color: 0x666644 });
            puzzleFloorMat = floorMatB;
            floorMesh = new THREE.Mesh(floorGeoB, floorMatB);
            floorMesh.receiveShadow = true;
            puzzleGroup.add(floorMesh);

            const floorShape = new CANNON.Box(new CANNON.Vec3(10, 0.5, 10));
            floorBody = new CANNON.Body({
                mass: 0,
                type: CANNON.Body.KINEMATIC,
                material: physicsMaterial
            });
            floorBody.addShape(floorShape);
            world.addBody(floorBody);

            const ballRadius = 0.8;
            const ballGeo = new THREE.SphereGeometry(ballRadius, 32, 32);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 });
            ballMesh = new THREE.Mesh(ballGeo, ballMat);
            ballMesh.castShadow = true;
            puzzleGroup.add(ballMesh);

            const ballShape = new CANNON.Sphere(ballRadius);
            ballBody = new CANNON.Body({
                mass: 5,
                shape: ballShape,
                material: physicsMaterial
            });
            ballBody.position.set(-5, 5, -5);
            ballBody.linearDamping = 0.1;
            world.addBody(ballBody);

            const targetGeo = new THREE.CylinderGeometry(
                TARGET_RADIUS,
                TARGET_RADIUS,
                0.1,
                32
            );
            const targetMat = new THREE.MeshBasicMaterial({
                color: 0x4ade80,
                opacity: 0.5,
                transparent: true
            });
            targetMesh = new THREE.Mesh(targetGeo, targetMat);
            targetMesh.position.set(TARGET_POS.x, 0.6, TARGET_POS.z);
            floorMesh.add(targetMesh);
        }

        // Events
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = true;
            if (e.key.toLowerCase() === 'r') restartGame();
        });
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) keys[e.key] = false;
        });

        // Setup UI and Joystick
        setupUIInteractions();
        setupJoystick();

        // Auto-save on tab close
        window.addEventListener('beforeunload', () => {
            saveGame(AUTO_SLOT);
        });

        updateInventoryUI();

        // Set up theme from system preference
        setupThemeFromSystem();

        // Apply autosave if present, otherwise start at menu
        if (pendingLoadData) {
            applyLoadedData(pendingLoadData, true);
        } else {
            loadMenu();
        }
    }

    // --- New UI & Joystick Logic ---

    function setupUIInteractions() {
        const gearBtn = document.getElementById('gear-btn');
        const menu = document.getElementById('expanded-menu');
        const closeBtn = document.getElementById('close-menu-btn');
        const saveUI = document.getElementById('save-ui');
        const themeUI = document.getElementById('theme-ui');

        // Toggle Menu
        function toggleMenu() {
            menu.classList.toggle('open');
        }

        gearBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // prevent raycaster click
            toggleMenu();
        });

        closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            menu.classList.remove('open');
        });

        // Save Handlers
        saveUI.addEventListener('click', (e) => {
            const btn = e.target;
            if (!(btn instanceof HTMLButtonElement)) return;
            const slot = btn.dataset.slot;
            const action = btn.dataset.action;
            if (!action) return;

            e.stopPropagation();

            if (action === 'save' || action === 'load') {
                if (!slot) return;
                if (action === 'save') {
                    saveGame(slot);
                    showStatus("Saved to " + slot.toUpperCase(), 1000);
                } else if (action === 'load') {
                    loadGame(slot);
                    toggleMenu(); // Close menu on load
                }
            } else if (action === 'restart') {
                fullRestart();
                toggleMenu();
            }
        });

        // Theme Handlers
        themeUI.addEventListener('click', (e) => {
            const btn = e.target;
            if (!(btn instanceof HTMLButtonElement)) return;
            const mode = btn.dataset.theme;
            if (!mode) return;
            e.stopPropagation();

            themeMode = mode;
            updateThemeButtons();
            recomputeTheme();
            saveGame(AUTO_SLOT);
        });
        updateThemeButtons();
    }

    function setupJoystick() {
        const zone = document.getElementById('joystick-zone');
        const knob = document.getElementById('joystick-knob');
        let startX = 0, startY = 0;
        let isDragging = false;
        const maxDist = 35; // Maximum drag distance

        zone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDragging = true;
            const touch = e.touches[0];
            const rect = zone.getBoundingClientRect();
            // Center of the joystick zone
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            startX = centerX;
            startY = centerY;
            
            updateJoystick(touch.clientX, touch.clientY);
        }, { passive: false });

        zone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!isDragging) return;
            const touch = e.touches[0];
            updateJoystick(touch.clientX, touch.clientY);
        }, { passive: false });

        const endDrag = (e) => {
            if (!isDragging) return;
            isDragging = false;
            knob.style.transform = `translate(-50%, -50%)`;
            // Reset keys
            keys.ArrowUp = false;
            keys.ArrowDown = false;
            keys.ArrowLeft = false;
            keys.ArrowRight = false;
        };

        zone.addEventListener('touchend', endDrag);
        zone.addEventListener('touchcancel', endDrag);

        function updateJoystick(clientX, clientY) {
            let dx = clientX - startX;
            let dy = clientY - startY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if (dist > maxDist) {
                const angle = Math.atan2(dy, dx);
                dx = Math.cos(angle) * maxDist;
                dy = Math.sin(angle) * maxDist;
            }

            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

            // Map to keys logic (thresholds)
            const threshold = 10;
            keys.ArrowRight = dx > threshold;
            keys.ArrowLeft = dx < -threshold;
            keys.ArrowDown = dy > threshold;
            keys.ArrowUp = dy < -threshold;
        }
    }

    // --- Utility: shuffle array ---
    function shuffleArray(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }

    // --- Screen shake helpers ---
    function startScreenShake(duration = 0.4, intensity = 0.6) {
        shakeDuration = duration;
        shakeTime = duration;
        shakeIntensity = intensity;
        cameraBasePosition.copy(camera.position);
    }

    function updateScreenShake() {
        if (shakeTime <= 0) return;

        const progress = 1 - shakeTime / shakeDuration;
        const damper = 1 - progress;

        const offsetX = (Math.random() - 0.5) * 2 * shakeIntensity * damper;
        const offsetY = (Math.random() - 0.5) * 2 * shakeIntensity * damper;

        camera.position.set(
            cameraBasePosition.x + offsetX,
            cameraBasePosition.y + offsetY,
            cameraBasePosition.z
        );

        shakeTime -= timeStep;
        if (shakeTime <= 0) {
            camera.position.copy(cameraBasePosition);
        }
    }

    // --- Visual theme helpers (light/dark) ---
    function applyTheme(mode) {
        if (!scene || !ambientLight || !dirLight) return;

        if (mode === "dark") {
            scene.background.set(0x050816);
            scene.fog.color.set(0x050816);
            ambientLight.intensity = 0.45;
            dirLight.intensity = 0.9;
            dirLight.color.set(0xbfd7ff);

            mazeFloorMats.forEach(m => {
                m.color.set(0x1e293b);
                m.roughness = 0.9;
                m.metalness = 0.0;
            });
            mazeWallMats.forEach(m => {
                m.color.set(0x020617);
                m.roughness = 0.9;
                m.metalness = 0.0;
            });
            if (puzzleFloorMat) {
                puzzleFloorMat.color.set(0x1f2933);
                puzzleFloorMat.roughness = 0.85;
                puzzleFloorMat.metalness = 0.05;
            }
        } else {
            scene.background.set(0xcbe5ff);
            scene.fog.color.set(0xcbe5ff);
            ambientLight.intensity = 0.95;
            dirLight.intensity = 0.85;
            dirLight.color.set(0xfff2cf);

            mazeFloorMats.forEach(m => {
                m.color.set(0xe2e8f0);
                m.roughness = 0.6;
                m.metalness = 0.1;
            });
            mazeWallMats.forEach(m => {
                m.color.set(0xf8fafc);
                m.roughness = 0.7;
                m.metalness = 0.0;
            });
            if (puzzleFloorMat) {
                puzzleFloorMat.color.set(0xfacc6b);
                puzzleFloorMat.roughness = 0.7;
                puzzleFloorMat.metalness = 0.1;
            }
        }
        renderer.setClearColor(scene.background);
    }

    function recomputeTheme() {
        const effective = themeMode === "light" || themeMode === "dark"
            ? themeMode
            : (systemPrefersDark ? "dark" : "light");
        applyTheme(effective);
    }

    function setupThemeFromSystem() {
        if (window.matchMedia) {
            const mq = window.matchMedia("(prefers-color-scheme: dark)");
            systemPrefersDark = mq.matches;
            recomputeTheme();

            if (mq.addEventListener) {
                mq.addEventListener("change", (e) => {
                    systemPrefersDark = e.matches;
                    if (themeMode === "system") {
                        recomputeTheme();
                    }
                });
            } else if (mq.addListener) {
                mq.addListener((e) => {
                    systemPrefersDark = e.matches;
                    if (themeMode === "system") {
                        recomputeTheme();
                    }
                });
            }
        } else {
            systemPrefersDark = false;
            recomputeTheme();
        }
    }

    function updateThemeButtons() {
        const themeUI = document.getElementById('theme-ui');
        const buttons = themeUI.querySelectorAll('button[data-theme]');
        buttons.forEach(btn => {
            if (btn.dataset.theme === themeMode) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
    }

    // --- Save system helpers ---
    function buildSaveData() {
        return {
            version: 2,
            currentMode,
            currentRoomRow,
            currentRoomCol,
            returnRoomRow,
            returnRoomCol,
            hasKey,
            inventory: Array.from(inventory),
            ballRoomCoord,
            plateRoomCoord,
            portalRoomCoord,
            themeMode
        };
    }

    function saveGame(slot = AUTO_SLOT) {
        try {
            const key = SAVE_PREFIX + slot;
            localStorage.setItem(key, JSON.stringify(buildSaveData()));
        } catch (e) {
            console.warn("Save failed:", e);
        }
    }

    function loadGame(slot) {
        try {
            const key = SAVE_PREFIX + slot;
            const raw = localStorage.getItem(key);
            if (!raw) {
                showStatus("No save in " + slot.toUpperCase(), 1500);
                return;
            }
            const data = JSON.parse(raw);
            applyLoadedData(data, false);
            showStatus("Loaded " + slot.toUpperCase(), 1000);
        } catch (e) {
            console.warn("Load failed:", e);
        }
    }

    function applyLoadedData(data, fromInit) {
        if (!data || typeof data !== "object") return;
        pendingLoadData = data;

        currentMode = data.currentMode || "maze";
        currentRoomRow = data.currentRoomRow ?? CENTER_ROW;
        currentRoomCol = data.currentRoomCol ?? CENTER_COL;
        returnRoomRow = data.returnRoomRow ?? CENTER_ROW;
        returnRoomCol = data.returnRoomCol ?? CENTER_COL;
        hasKey = !!data.hasKey;

        inventory.clear();
        if (Array.isArray(data.inventory)) {
            data.inventory.forEach(id => inventory.add(id));
        }

        ballRoomCoord = data.ballRoomCoord || ballRoomCoord;
        plateRoomCoord = data.plateRoomCoord || plateRoomCoord;
        portalRoomCoord = data.portalRoomCoord || portalRoomCoord;

        if (data.themeMode) {
            themeMode = data.themeMode;
            updateThemeButtons();
        }

        updateInventoryUI();

        recomputeTheme();

        if (currentMode === "maze") {
            showMazeRoom(currentRoomRow, currentRoomCol, fromInit);
        } else if (currentMode === "puzzle") {
            loadPuzzleScene();
        } else if (currentMode === "ending") {
            loadEnding();
        } else {
            loadMenu();
        }
    }

    // --- Full game restart ---
    function fullRestart() {
        try {
            ["slot1", "slot2", "slot3", AUTO_SLOT].forEach(slot => {
                localStorage.removeItem(SAVE_PREFIX + slot);
            });
        } catch (e) {
            console.warn("Failed to clear saves:", e);
        }

        // Reset in-memory state
        currentMode = "menu";
        currentRoomRow = CENTER_ROW;
        currentRoomCol = CENTER_COL;
        returnRoomRow = CENTER_ROW;
        returnRoomCol = CENTER_COL;
        hasKey = false;
        inventory.clear();
        pendingLoadData = null;

        updateInventoryUI();
        showStatus("Game fully restarted.", 1200);

        // Go back to main menu and create a fresh autosave
        loadMenu();
    }

    // --- Scene helpers ---
    function refreshItemVisibility() {
        for (let r = 0; r < NUM_ROWS; r++) {
            for (let c = 0; c < NUM_COLS; c++) {
                const g = mazeRooms[r][c];
                g.children.forEach(obj => {
                    if (obj.userData && obj.userData.type === "item") {
                        const id = obj.userData.itemId;
                        obj.visible = !inventory.has(id);
                    }
                });
            }
        }
    }

    function hideAllRooms() {
        for (let r = 0; r < NUM_ROWS; r++) {
            for (let c = 0; c < NUM_COLS; c++) {
                mazeRooms[r][c].visible = false;
            }
        }
        menuGroup.visible = false;
        puzzleGroup.visible = false;
    }

    function toggleJoystick(visible) {
        const joy = document.getElementById('joystick-zone');
        // Only show joystick if game requests it AND we are on mobile
        joy.style.display = (visible && isMobileDevice) ? 'block' : 'none';
    }

    function loadMenu() {
        currentMode = "menu";
        hideAllRooms();
        toggleJoystick(false);
        menuGroup.visible = true;

        const instr = document.getElementById('instructions');
        const startText = document.getElementById('start-text');
        const statusEl = document.getElementById('status-msg');

        statusEl.style.display = 'none';
        statusEl.className = '';

        camera = perspCamera;
        camera.position.set(0, 12, 15);
        camera.lookAt(0, 10, 0);
        cameraBasePosition.copy(camera.position);

        instr.style.display = 'none';
        startText.style.display = 'block';

        saveGame(AUTO_SLOT);
    }

    function showMazeRoom(row, col, skipSave = false) {
        currentMode = "maze";
        currentRoomRow = row;
        currentRoomCol = col;

        hideAllRooms();
        toggleJoystick(false);
        mazeRooms[row][col].visible = true;

        const instr = document.getElementById('instructions');
        const startText = document.getElementById('start-text');
        const statusEl = document.getElementById('status-msg');

        startText.style.display = 'none';
        statusEl.style.display = 'none';
        statusEl.className = '';

        camera = orthoCamera;
        camera.position.set(0, 25, 0);
        camera.lookAt(0, 0, 0);
        camera.up.set(0, 0, -1);
        cameraBasePosition.copy(camera.position);

        instr.style.display = 'block';

        const isCenter = (row === CENTER_ROW && col === CENTER_COL);

        if (isCenter) {
            instr.innerHTML = `
                <h2>Central Room</h2>
                <p>You are in the <b>center</b> of a 3×3 maze.</p>
                <p>Find a <b>ball</b>, a <b>plate</b>, and a <b>locked portal</b>.</p>
                <p>Collect both items to be dragged into a gravity puzzle.</p>
                <p>Beat the puzzle to earn a <b>key</b>, then find the portal room and escape.</p>
            `;
        } else {
            instr.innerHTML = `
                <h2>Maze Room</h2>
                <p>This is one of the nine rooms in the maze.</p>
                <p>Click objects to interact, and doors to move to adjacent rooms.</p>
                <p>You need a <b>ball</b>, a <b>plate</b>, then the puzzle key to open the portal.</p>
            `;
        }

        if (!skipSave) {
            saveGame(AUTO_SLOT);
        }
    }

    function loadPuzzleScene() {
        currentMode = "puzzle";
        hideAllRooms();
        toggleJoystick(true); // Enable Joystick (will check mobile flag inside)
        puzzleGroup.visible = true;

        const instr = document.getElementById('instructions');
        const startText = document.getElementById('start-text');
        const statusEl = document.getElementById('status-msg');

        startText.style.display = 'none';
        statusEl.style.display = 'none';
        statusEl.className = '';

        // Reset Perspective Camera (Zoom check logic in Init/Resize)
        const aspect = window.innerWidth / window.innerHeight;
        const isPortrait = aspect < 1.0;
        const puzzleCamDist = isPortrait ? 45 : 25;
        const puzzleCamHeight = isPortrait ? 35 : 20;

        camera = perspCamera;
        camera.position.set(0, puzzleCamHeight, puzzleCamDist);
        camera.lookAt(0, 0, 0);
        cameraBasePosition.copy(camera.position);

        instr.style.display = 'block';
        instr.innerHTML = `
            <h2>Gravity Puzzle Room</h2>
            <p>Use <b>Arrow Keys</b> or <b>Joystick</b> to tilt the floor.</p>
            <p>Roll the ball into the <b>green zone</b>.</p>
            <p>Don't fall off! Press <b>R</b> to restart the puzzle.</p>
        `;
        restartGame();
        saveGame(AUTO_SLOT);
    }

    function loadEnding() {
        currentMode = "ending";
        hideAllRooms();
        toggleJoystick(false);
        const instr = document.getElementById('instructions');
        const statusEl = document.getElementById('status-msg');
        const startText = document.getElementById('start-text');

        instr.style.display = 'none';
        startText.style.display = 'none';

        camera = perspCamera;
        camera.position.set(0, 12, 15);
        camera.lookAt(0, 0, 0);
        cameraBasePosition.copy(camera.position);

        statusEl.style.display = 'block';
        statusEl.className = 'win';
        statusEl.textContent = "You step through the portal and escape the maze!\nThanks for playing.";
        showStatus("The labyrinth dissolves behind you...", 3000);

        saveGame(AUTO_SLOT);
    }

    function updateInventoryUI() {
        const invEl = document.getElementById('inventory-ui');
        if (!invEl) return;
        if (inventory.size === 0) {
            invEl.textContent = 'Inventory: (empty)';
        } else {
            invEl.textContent = 'Inventory: ' + Array.from(inventory).join(', ');
        }
        refreshItemVisibility();
    }

    function showStatus(text, timeout = 2000) {
        const msgEl = document.getElementById('message');
        if (!msgEl) return;
        msgEl.textContent = text;
        msgEl.style.display = 'block';
        if (timeout > 0) {
            clearTimeout(showStatus._timeoutId);
            showStatus._timeoutId = setTimeout(() => {
                msgEl.style.display = 'none';
            }, timeout);
        }
    }

    // --- Input / interaction ---
    function onPointerDown(event) {
        // Prevent clicking through the menu overlay if open
        const menu = document.getElementById('expanded-menu');
        if (menu.classList.contains('open')) return;
        
        // Prevent clicking through joystick
        if (event.target.closest('#joystick-zone')) return;
        if (event.target.closest('#gear-btn')) return;

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        let clickable = [];
        if (currentMode === "menu") {
            clickable = menuGroup.children;
        } else if (currentMode === "maze") {
            clickable = mazeRooms[currentRoomRow][currentRoomCol].children;
        } else if (currentMode === "puzzle") {
            clickable = puzzleGroup.children;
        } else {
            return;
        }

        const hits = raycaster.intersectObjects(clickable, true);
        if (hits.length === 0) return;

        const obj = hits[0].object;

        // MENU
        if (currentMode === "menu" && obj.userData.type === "startGame") {
            showMazeRoom(CENTER_ROW, CENTER_COL);
            return;
        }

        // MAZE
        if (currentMode === "maze") {
            if (obj.userData.type === "item") {
                const id = obj.userData.itemId;
                if (!inventory.has(id)) {
                    inventory.add(id);
                    updateInventoryUI();
                    showStatus("Picked up " + id + "!");
                }

                // If ball + plate collected and no key yet -> auto enter puzzle
                if (inventory.has("ball") && inventory.has("plate") && !hasKey) {
                    returnRoomRow = currentRoomRow;
                    returnRoomCol = currentRoomCol;

                    startScreenShake(0.45, 0.8);
                    showStatus("The floor trembles... you are dragged elsewhere!", 2000);
                    saveGame(AUTO_SLOT);
                    setTimeout(() => {
                        loadPuzzleScene();
                    }, 800);
                } else {
                    saveGame(AUTO_SLOT);
                }
                return;
            }

            if (obj.userData.type === "door") {
                const kind = obj.userData.kind || "mazeDoor";

                if (kind === "mazeDoor") {
                    const nr = obj.userData.row;
                    const nc = obj.userData.col;
                    showMazeRoom(nr, nc);
                    return;
                }

                if (kind === "finalExit") {
                    if (!hasKey) {
                        showStatus("The portal is sealed. A key-shaped slot glows faintly.");
                    } else {
                        showStatus("You raise the key. The portal roars to life...");
                        loadEnding();
                    }
                    return;
                }
            }
        }
    }

    // --- Puzzle control & physics ---
    function restartGame() {
        if (!ballBody || !floorBody) return;
        gameActive = true;

        ballBody.position.set(-5, 5, -5);
        ballBody.velocity.set(0, 0, 0);
        ballBody.angularVelocity.set(0, 0, 0);

        floorBody.quaternion.setFromEuler(0, 0, 0);

        const statusEl = document.getElementById('status-msg');
        statusEl.style.display = 'none';
        statusEl.className = '';
    }

    function updatePhysics() {
        if (currentMode !== "puzzle") return;
        if (!ballBody || !floorBody) return;

        if (gameActive) {
            const maxTilt = 0.3;

            const currentEuler = new CANNON.Vec3();
            floorBody.quaternion.toEuler(currentEuler);

            let targetX = 0;
            let targetZ = 0;

            if (keys.ArrowUp) targetX = -maxTilt;
            if (keys.ArrowDown) targetX = maxTilt;
            if (keys.ArrowLeft) targetZ = maxTilt;
            if (keys.ArrowRight) targetZ = -maxTilt;

            currentEuler.x += (targetX - currentEuler.x) * 0.05;
            currentEuler.z += (targetZ - currentEuler.z) * 0.05;

            floorBody.quaternion.setFromEuler(currentEuler.x, 0, currentEuler.z);
        }

        world.step(timeStep);

        ballMesh.position.copy(ballBody.position);
        ballMesh.quaternion.copy(ballBody.quaternion);

        floorMesh.position.copy(floorBody.position);
        floorMesh.quaternion.copy(floorBody.quaternion);

        if (gameActive) {
            checkWinCondition();
        }
    }

    function checkWinCondition() {
        if (ballBody.position.y < -10) {
            endGame(false);
        }

        const dx = ballBody.position.x - TARGET_POS.x;
        const dz = ballBody.position.z - TARGET_POS.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < TARGET_RADIUS && ballBody.position.y > -1) {
            endGame(true);
        }
    }

    function endGame(isWin) {
        gameActive = false;
        const statusEl = document.getElementById('status-msg');
        statusEl.style.display = 'block';

        if (isWin) {
            statusEl.textContent = "SUCCESS!\nYou obtained a key.";
            statusEl.className = 'win';

            if (!hasKey) {
                hasKey = true;
                inventory.add("key");
                updateInventoryUI();
                showStatus("A strange key appears in your hand.\nYou are pulled back into the maze.", 2500);
            }

            setTimeout(() => {
                showMazeRoom(returnRoomRow, returnRoomCol);
            }, 1500);
        } else {
            statusEl.textContent = "FAILURE";
            statusEl.className = 'lose';
            showStatus("You can press R to retry the puzzle.");
        }
        saveGame(AUTO_SLOT);
    }

    // --- Misc ---
    function onWindowResize() {
        const aspect = window.innerWidth / window.innerHeight;
        const isPortrait = aspect < 1.0;

        // Dynamic Zoom Scaling for Ortho (Maze)
        let effectiveViewSize = viewSize;
        if (isPortrait) {
            effectiveViewSize = viewSize * 1.5;
        }

        orthoCamera.left   = -effectiveViewSize * aspect;
        orthoCamera.right  =  effectiveViewSize * aspect;
        orthoCamera.top    =  effectiveViewSize;
        orthoCamera.bottom = -effectiveViewSize;
        orthoCamera.updateProjectionMatrix();

        // Dynamic Zoom Scaling for Perspective (Puzzle)
        // If portrait, zoom out (increase Z) to see the board
        const puzzleCamDist = isPortrait ? 45 : 25;
        const puzzleCamHeight = isPortrait ? 35 : 20;

        perspCamera.aspect = aspect;
        // Only update position if we are currently in puzzle mode to avoid jumping
        // or update it generally but rely on loadPuzzleScene to reset it correctly
        if (currentMode === 'puzzle') {
             perspCamera.position.set(0, puzzleCamHeight, puzzleCamDist);
             perspCamera.lookAt(0,0,0);
        }
        perspCamera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        updatePhysics();
        updateScreenShake();
        renderer.render(scene, camera);
    }
    </script>
</body>
</html>
